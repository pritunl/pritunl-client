{"version":3,"file":"main.js","mappings":";;;;;;;AAAA;;;;;;;ACAa;;AAEb,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAc;;AAE7C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,yBAAyB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,mBAAmB;AAC5B;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ,4BAA4B;AACpC;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV,iEAAiE,EAAE;AACnE;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE,GAAG,EAAE;AAC1D,2BAA2B;AAC3B,eAAe;AACf;AACA,qBAAqB;AACrB,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,mBAAmB;;;;;;;;AC1MN;;AAEb,QAAQ,WAAW,EAAE,mBAAO,CAAC,GAAQ;;AAErC,0BAA0B,mBAAO,CAAC,GAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,GAAa;AACzB,QAAQ,gCAAgC,EAAE,mBAAO,CAAC,GAAe;AACjE,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,GAAc;;AAEjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,mCAAmC,KAAK;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,QAAQ;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACjsBA,sCAAsC,kEAAkE;;AAE3F;;AAEb,qBAAqB,mBAAO,CAAC,GAAQ;AACrC,cAAc,mBAAO,CAAC,GAAO;AAC7B,aAAa,mBAAO,CAAC,GAAM;AAC3B,YAAY,mBAAO,CAAC,GAAK;AACzB,YAAY,mBAAO,CAAC,GAAK;AACzB,QAAQ,0BAA0B,EAAE,mBAAO,CAAC,GAAQ;AACpD,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,GAAQ;AAC7C,QAAQ,MAAM,EAAE,mBAAO,CAAC,EAAK;;AAE7B,0BAA0B,mBAAO,CAAC,GAAsB;AACxD,iBAAiB,mBAAO,CAAC,EAAY;AACrC,eAAe,mBAAO,CAAC,GAAU;AACjC,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAc;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,GAAa;AACzB;AACA,iBAAiB;AACjB,EAAE,EAAE,mBAAO,CAAC,GAAgB;AAC5B,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,EAAa;AAC/C,QAAQ,WAAW,EAAE,mBAAO,CAAC,GAAe;;AAE5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,mBAAmB;AAChC,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,UAAU;AACvB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,kBAAkB;AAC7B;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,sBAAsB;AAC7D,gCAAgC,4BAA4B;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN,4CAA4C,QAAQ;AACpD;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB,GAAG,mBAAmB;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR,oDAAoD,SAAS;AAC7D;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,4CAA4C;AACvD;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,sBAAsB;AACjE,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,8BAA8B;AACzC,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC32CA;;;;;;;ACAA,sCAAsC,gCAAgC;;AAEzD;;AAEb,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAQ;AACnC,QAAQ,iBAAiB,EAAE,mBAAO,CAAC,GAAQ;;AAE3C,0BAA0B,mBAAO,CAAC,GAAsB;AACxD,QAAQ,iCAAiC,EAAE,mBAAO,CAAC,GAAa;AAChE,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,GAAc;AAC5D,QAAQ,4BAA4B,EAAE,mBAAO,CAAC,GAAe;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzlBA,sCAAsC,yDAAyD;;AAElF;;AAEb,qBAAqB,mBAAO,CAAC,GAAQ;AACrC,aAAa,mBAAO,CAAC,GAAM;AAC3B,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAQ;AACnC,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAQ;;AAEvC,kBAAkB,mBAAO,CAAC,EAAa;AACvC,0BAA0B,mBAAO,CAAC,GAAsB;AACxD,oBAAoB,mBAAO,CAAC,GAAe;AAC3C,kBAAkB,mBAAO,CAAC,EAAa;AACvC,QAAQ,mBAAmB,EAAE,mBAAO,CAAC,GAAa;;AAElD,iCAAiC,GAAG;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB,aAAa,kBAAkB;AAC/B;AACA,aAAa,QAAQ;AACrB,aAAa,4BAA4B;AACzC;AACA,aAAa,SAAS;AACtB;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB;AACA,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAkD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,aAAa,sBAAsB;AACnC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,2BAA2B;AACtC,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,MAAM,EAAE,wBAAwB;AAChD;AACA,uBAAuB,EAAE,IAAI,WAAW;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;AC3hBA;;;;;;;ACAA;;;;;;;ACAa;;AAEb,QAAQ,aAAa,EAAE,mBAAO,CAAC,GAAc;;AAE7C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU,mBAAmB;AAC7B;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,+DAA+D,EAAE;AACjE;;AAEA;;AAEA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;;AAEA;AACA;AACA,MAAM;AACN,6DAA6D,EAAE;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;AC7DnB;;;;;;;ACAa;;AAEb,aAAa,mBAAO,CAAC,GAAM;;AAE3B,mBAAmB,mBAAO,CAAC,GAAe;AAC1C,gBAAgB,mBAAO,CAAC,GAAW;AACnC,QAAQ,cAAc,EAAE,mBAAO,CAAC,GAAa;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,kBAAkB;AAC/B;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,kBAAkB;AAC/B;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,KAAK,MAAM;AAC/D;AACA;AACA;AACA,YAAY;AACZ;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,UAAU;AACV,gDAAgD,IAAI;AACpD;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,SAAS;AACtB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjgBa;;AAEb,QAAQ,eAAe,EAAE,mBAAO,CAAC,GAAa;;AAE9C;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,QAAQ;AACpB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,EAAW;AAChB;AACA,uBAAuB,mBAAO,CAAC,GAAY;;AAE3C,IAAI,mBAAmB;AACvB;AACA;AACA;;AAEA,IAAI,qBAAqB;AACzB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;AClIA;;;;;;;ACAA,4CAA4C,0DAA0D,6BAA6B;;AAEnI;;;;;;;ACFa;;AAEb;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA,sCAAsC,oCAAoC;AAC7D;;AAEb,kBAAkB,mBAAO,CAAC,EAAa;AACvC,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAQ;;AAEnC;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;AChKa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtDA;;;;;;;ACAA,wCAAwC,sDAAsD,6BAA6B;;AAE3H;;;;;;;ACFA;;;;;;;ACAa;;AAEb,QAAQ,SAAS,EAAE,mBAAO,CAAC,GAAQ;;AAEnC,QAAQ,UAAU,EAAE,mBAAO,CAAC,GAAa;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,0BAA0B;AAC5B;AACA;AACA,EAAE,sCAAsC,EAAW;AACnD;AACA,wBAAwB,mBAAO,CAAC,GAAgB;;AAEhD,IAAI,0BAA0B;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;;;;;;;;ACvJA;;;;;;;ACAa;;AAEb,QAAQ,kCAAkC,EAAE,mBAAO,CAAC,GAAa;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,kBAAkB;AACrE,iDAAiD,kBAAkB;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,kBAAkB;AACxE,wDAAwD,kBAAkB;AAC1E,0DAA0D,kBAAkB;;AAE5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,GAAG;AAChB,aAAa,QAAQ;AACrB;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,uDAAuD,kBAAkB;AACzE,yDAAyD,kBAAkB;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA,aAAa,GAAG;AAChB;AACA,gCAAgC;AAChC;;AAEA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA,wDAAwD,kBAAkB;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,mBAAmB;AAChC,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,GAAG;AACd,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","sources":["webpack://pritunl/external node-commonjs \"url\"","webpack://pritunl/./node_modules/ws/lib/extension.js","webpack://pritunl/./node_modules/ws/lib/receiver.js","webpack://pritunl/./node_modules/ws/lib/websocket.js","webpack://pritunl/external node-commonjs \"zlib\"","webpack://pritunl/./node_modules/ws/lib/sender.js","webpack://pritunl/./node_modules/ws/lib/websocket-server.js","webpack://pritunl/external node-commonjs \"buffer\"","webpack://pritunl/external node-commonjs \"stream\"","webpack://pritunl/./node_modules/ws/lib/subprotocol.js","webpack://pritunl/external node-commonjs \"net\"","webpack://pritunl/./node_modules/ws/lib/permessage-deflate.js","webpack://pritunl/./node_modules/ws/lib/buffer-util.js","webpack://pritunl/external node-commonjs \"events\"","webpack://pritunl/external var \"utf-8-validate\"","webpack://pritunl/./node_modules/ws/lib/constants.js","webpack://pritunl/./node_modules/ws/lib/stream.js","webpack://pritunl/./node_modules/ws/lib/limiter.js","webpack://pritunl/external node-commonjs \"http\"","webpack://pritunl/external var \"bufferutil\"","webpack://pritunl/external node-commonjs \"https\"","webpack://pritunl/./node_modules/ws/lib/validation.js","webpack://pritunl/external node-commonjs \"tls\"","webpack://pritunl/./node_modules/ws/lib/event-target.js","webpack://pritunl/external node-commonjs \"crypto\"","webpack://pritunl/webpack/bootstrap","webpack://pritunl/webpack/runtime/compat get default export","webpack://pritunl/webpack/runtime/create fake namespace object","webpack://pritunl/webpack/runtime/define property getters","webpack://pritunl/webpack/runtime/hasOwnProperty shorthand","webpack://pritunl/webpack/runtime/make namespace object","webpack://pritunl/external node-commonjs \"process\"","webpack://pritunl/external node-commonjs \"path\"","webpack://pritunl/external node-commonjs \"fs\"","webpack://pritunl/external node-commonjs \"electron\"","webpack://pritunl/external node-commonjs \"child_process\"","webpack://pritunl/./main/Utils.ts","webpack://pritunl/./node_modules/ws/wrapper.mjs","webpack://pritunl/./main/Auth.ts","webpack://pritunl/./main/Errors.ts","webpack://pritunl/external node-commonjs \"os\"","webpack://pritunl/./main/Constants.ts","webpack://pritunl/./main/Logger.ts","webpack://pritunl/./main/Request.ts","webpack://pritunl/./main/RequestUtils.ts","webpack://pritunl/./app/Errors.ts","webpack://pritunl/external node-commonjs \"node:events\"","webpack://pritunl/external node-commonjs \"node:stream\"","webpack://pritunl/external node-commonjs \"node:string_decoder\"","webpack://pritunl/external node-commonjs \"node:path\"","webpack://pritunl/external node-commonjs \"node:fs\"","webpack://pritunl/external node-commonjs \"assert\"","webpack://pritunl/external node-commonjs \"node:assert\"","webpack://pritunl/external node-commonjs \"node:crypto\"","webpack://pritunl/external node-commonjs \"node:fs/promises\"","webpack://pritunl/./node_modules/tar/node_modules/@isaacs/fs-minipass/src/index.ts","webpack://pritunl/./node_modules/tar/node_modules/minipass/src/index.ts","webpack://pritunl/./node_modules/tar/src/create.ts","webpack://pritunl/./node_modules/tar/src/list.ts","webpack://pritunl/./node_modules/tar/src/options.ts","webpack://pritunl/./node_modules/tar/src/make-command.ts","webpack://pritunl/./node_modules/tar/src/parse.ts","webpack://pritunl/./node_modules/tar/node_modules/minizlib/src/index.ts","webpack://pritunl/./node_modules/tar/node_modules/minizlib/src/constants.ts","webpack://pritunl/./node_modules/tar/src/header.ts","webpack://pritunl/./node_modules/tar/src/large-numbers.ts","webpack://pritunl/./node_modules/tar/src/types.ts","webpack://pritunl/./node_modules/tar/src/pax.ts","webpack://pritunl/./node_modules/tar/src/normalize-windows-path.ts","webpack://pritunl/./node_modules/tar/src/read-entry.ts","webpack://pritunl/./node_modules/tar/src/warn-method.ts","webpack://pritunl/./node_modules/tar/src/strip-trailing-slashes.ts","webpack://pritunl/./node_modules/tar/src/pack.ts","webpack://pritunl/./node_modules/tar/src/write-entry.ts","webpack://pritunl/./node_modules/tar/src/mode-fix.ts","webpack://pritunl/./node_modules/tar/src/strip-absolute-path.ts","webpack://pritunl/./node_modules/tar/src/winchars.ts","webpack://pritunl/./node_modules/tar/node_modules/yallist/src/index.ts","webpack://pritunl/./node_modules/tar/src/extract.ts","webpack://pritunl/./node_modules/tar/src/unpack.ts","webpack://pritunl/./node_modules/tar/src/get-write-flag.ts","webpack://pritunl/./node_modules/tar/node_modules/chownr/src/index.ts","webpack://pritunl/./node_modules/tar/src/mkdir.ts","webpack://pritunl/./node_modules/tar/src/cwd-error.ts","webpack://pritunl/./node_modules/tar/src/symlink-error.ts","webpack://pritunl/./node_modules/tar/src/path-reservations.ts","webpack://pritunl/./node_modules/tar/src/normalize-unicode.ts","webpack://pritunl/./node_modules/tar/src/process-umask.ts","webpack://pritunl/./node_modules/tar/src/replace.ts","webpack://pritunl/./node_modules/tar/src/update.ts","webpack://pritunl/./app/utils/MiscUtils.ts","webpack://pritunl/./main/Service.ts","webpack://pritunl/./main/Config.ts","webpack://pritunl/./main/Tpm.ts","webpack://pritunl/./main/Main.tsx"],"sourcesContent":["module.exports = require(\"url\");","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Duplex, Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst { isBlob } = require('./validation');\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","module.exports = require(\"zlib\");","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n'use strict';\n\nconst { Duplex } = require('stream');\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = require('./constants');\nconst { isBlob, isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst http = require('http');\nconst { Duplex } = require('stream');\nconst { createHash } = require('crypto');\n\nconst extension = require('./extension');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst subprotocol = require('./subprotocol');\nconst WebSocket = require('./websocket');\nconst { GUID, kWebSocket } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n","module.exports = require(\"buffer\");","module.exports = require(\"stream\");","'use strict';\n\nconst { tokenChars } = require('./validation');\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n","module.exports = require(\"net\");","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = require('bufferutil');\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","module.exports = require(\"events\");","if(typeof utf-8-validate === 'undefined') { var e = new Error(\"Cannot find module 'utf-8-validate'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }\n\nmodule.exports = utf-8-validate;","'use strict';\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n","/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n'use strict';\n\nconst WebSocket = require('./websocket');\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","module.exports = require(\"http\");","if(typeof bufferutil === 'undefined') { var e = new Error(\"Cannot find module 'bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }\n\nmodule.exports = bufferutil;","module.exports = require(\"https\");","'use strict';\n\nconst { isUtf8 } = require('buffer');\n\nconst { hasBlob } = require('./constants');\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = require('utf-8-validate');\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n","module.exports = require(\"tls\");","'use strict';\n\nconst { kForOnEventAttribute, kListener } = require('./constants');\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n","module.exports = require(\"crypto\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"process\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"electron\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"child_process\");","import electron from \"electron\"\nimport process from \"process\";\nimport childprocess from \"child_process\";\n\nexport function uuid(): string {\n\treturn (+new Date() + Math.floor(Math.random() * 999999)).toString(36);\n}\n\nexport function uuidRand(): string {\n\tlet id = \"\"\n\n\tfor (let i = 0; i < 4; i++) {\n\t\tid += Math.floor((1 + Math.random()) * 0x10000).toString(\n\t\t\t16).substring(1);\n\t}\n\n\treturn id;\n}\n\nexport function openLink(url: string): boolean {\n\tlet u = new URL(url)\n\n\tif (u.protocol !== \"http:\" && u.protocol !== \"https:\") {\n\t\treturn false\n\t}\n\tif (!u.hostname) {\n\t\treturn false\n\t}\n\tif (u.port && Number.isNaN(u.port)) {\n\t\treturn false\n\t}\n\n\tlet urlParsed = u.protocol + \"//\" + u.hostname\n\tif (u.port) {\n\t\turlParsed += \":\" + u.port\n\t}\n\tif (u.pathname) {\n\t\turlParsed += u.pathname\n\t}\n\tif (u.search) {\n\t\turlParsed += u.search\n\t}\n\tif (u.hash) {\n\t\turlParsed += u.hash\n\t}\n\n\tif (process.platform === \"linux\") {\n\t\tchildprocess.execFile(\n\t\t\t\"xdg-open\", [urlParsed],\n\t\t\t(err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\telectron.shell.openExternal(urlParsed)\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\t} else {\n\t\telectron.shell.openExternal(urlParsed)\n\t}\n\n\treturn true\n}\n","import createWebSocketStream from './lib/stream.js';\nimport Receiver from './lib/receiver.js';\nimport Sender from './lib/sender.js';\nimport WebSocket from './lib/websocket.js';\nimport WebSocketServer from './lib/websocket-server.js';\n\nexport { createWebSocketStream, Receiver, Sender, WebSocket, WebSocketServer };\nexport default WebSocket;\n","import fs from \"fs\";\nimport process from \"process\";\nimport path from \"path\";\nimport {winDrive} from \"./Service\";\n\nexport let token = '';\nexport let unix = false\nexport const unixPath = \"/var/run/pritunl.sock\"\nexport const webHost = \"http://127.0.0.1:9770\"\n\nif (process.platform === \"linux\" || process.platform === \"darwin\") {\n\tunix = true\n}\n\nfunction getAuthPath(): string {\n\tif (process.platform === \"win32\") {\n\t\treturn path.join(winDrive, \"ProgramData\", \"Pritunl\", \"auth\")\n\t} else {\n\t\treturn path.join(path.sep, \"var\", \"run\", \"pritunl.auth\")\n\t}\n}\n\nexport function _load(): void {\n\tfs.readFile(getAuthPath(), 'utf-8', (err, data: string): void => {\n\t\tif (err || !data) {\n\t\t\tsetTimeout((): void => {\n\t\t\t\t_load();\n\t\t\t}, 100);\n\t\t\treturn;\n\t\t}\n\n\t\ttoken = data.trim();\n\n\t\tsetTimeout((): void => {\n\t\t\t_load();\n\t\t}, 3000);\n\t});\n}\n\nexport function load(): Promise<void> {\n\treturn new Promise<void>((resolve, reject): void => {\n\t\tfs.readFile(getAuthPath(), 'utf-8', (err, data: string): void => {\n\t\t\tif (err || !data) {\n\t\t\t\tsetTimeout((): void => {\n\t\t\t\t\t_load();\n\t\t\t\t}, 100);\n\t\t\t\tresolve();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttoken = data.trim();\n\t\t\tresolve();\n\n\t\t\tsetTimeout((): void => {\n\t\t\t\t_load();\n\t\t\t}, 3000);\n\t\t})\n\t})\n}\n","export class BaseError extends Error {\n\tconstructor(name: string, wrapErr: Error, message: string,\n\t\targs?: {[key: string]: any}) {\n\n\t\tsuper()\n\n\t\tif (args) {\n\t\t\tfor (let key in args) {\n\t\t\t\tmessage += \" \" + key + \"=\" + args[key]\n\t\t\t}\n\t\t}\n\n\t\tif (wrapErr) {\n\t\t\tmessage += \"\\n\" + wrapErr\n\t\t}\n\n\t\tthis.name = name\n\t\tthis.message = message\n\t\tif (wrapErr) {\n\t\t\tthis.stack = wrapErr.stack\n\t\t}\n\t}\n}\n\nexport class ReadError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"ReadError\", wrapErr, message, args)\n\t}\n}\n\nexport class WriteError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"WriteError\", wrapErr, message, args)\n\t}\n}\n\nexport class RequestError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"RequestError\", wrapErr, message, args)\n\t}\n}\n\nexport class ProcessError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"ProcessError\", wrapErr, message, args)\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","import electron from \"electron\"\nimport path from \"path\"\nimport os from \"os\"\nimport process from \"process\"\n\nexport let unix = false\nexport const unixPath = \"/var/run/pritunl.sock\"\nexport const webHost = \"http://127.0.0.1:9770\"\nexport const unixWsHost = \"ws+unix://\" + path.join(\n\tpath.sep, \"var\", \"run\", \"pritunl.sock\") + \":\"\nexport const webWsHost = \"ws://127.0.0.1:9770\"\nexport const platform = os.platform()\nexport const hostname = os.hostname()\nexport const logPath = path.join(electron.app.getPath(\"userData\"),\n\t\"pritunl.log\");\nexport let mainWindow: electron.BrowserWindow\n\nexport let production = (process.argv.indexOf(\"--dev\") === -1)\nexport let devTools = (process.argv.indexOf(\"--dev-tools\") !== -1)\n\nexport let winDrive = \"C:\\\\\"\nlet systemDrv = process.env.SYSTEMDRIVE\nif (systemDrv) {\n\twinDrive = systemDrv + \"\\\\\"\n}\n\nif (process.platform === \"linux\" || process.platform === \"darwin\") {\n\tunix = true\n}\n\nexport function setMainWindow(mainWin: electron.BrowserWindow) {\n\tmainWindow = mainWin\n}\n","import fs from \"fs\"\nimport path from \"path\"\nimport electron from \"electron\"\nimport * as Errors from \"./Errors\"\nimport * as Constants from \"./Constants\";\n\nfunction push(level: string, err: any): void {\n\tif (!err) {\n\t\terr = \"Undefined error\"\n\t}\n\n\tlet time = new Date()\n\tlet msg = err.message || err\n\n\tmsg = \"[\" + time.getFullYear() + \"-\" + (time.getMonth() + 1) + \"-\" +\n\t\ttime.getDate() + \" \" + time.getHours() + \":\" + time.getMinutes() + \":\" +\n\t\ttime.getSeconds() + \"][\" + level  + \"] \" + msg + \"\\n\" + (err.stack || \"\")\n\n\tmsg = msg.trim()\n\n\tlet pth = Constants.logPath\n\n\tfs.stat(pth, (err: Error, stat) => {\n\t\tif (stat && stat.size > 200000) {\n\t\t\tfs.unlink(pth, () => {\n\t\t\t\tfs.appendFile(pth, msg + \"\\n\", (err: Error): void => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\terr = new Errors.WriteError(err, \"Logger: Failed to write log\",\n\t\t\t\t\t\t\t{log_path: pth})\n\t\t\t\t\t\tconsole.error(err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t})\n\t\t} else {\n\t\t\tfs.appendFile(pth, msg + \"\\n\", (err: Error): void => {\n\t\t\t\tif (err) {\n\t\t\t\t\terr = new Errors.WriteError(err, \"Logger: Failed to write log\",\n\t\t\t\t\t\t{log_path: pth})\n\t\t\t\t\tconsole.error(err)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t})\n}\n\nexport function info(err: any): void {\n\tpush(\"INFO\", err)\n}\n\nexport function warning(err: any): void {\n\tpush(\"WARN\", err)\n}\n\nexport function error(err: any): void {\n\tpush(\"ERROR\", err)\n}\n","import http from \"http\"\nimport https from \"https\"\nimport * as Logger from \"./Logger\"\nimport * as Errors from \"./Errors\"\n\nexport var DefaultTimeout = 20\n\nexport class Response {\n\tresponse: http.IncomingMessage\n\theaders: Map<string, string>\n\tstatus: number\n\tmessage: string\n\tdata: string\n\n\tconstructor(res: http.IncomingMessage) {\n\t\tthis.response = res\n\t\tthis.status = res.statusCode\n\t\tthis.message = res.statusMessage\n\t}\n\n\tget(key: string): string {\n\t\tif (this.headers) {\n\t\t\treturn this.headers.get(key)\n\t\t}\n\n\t\tlet curKey: string = null\n\t\tlet headers = new Map<string, string>()\n\n\t\tfor (let item of this.response.rawHeaders) {\n\t\t\tif (curKey) {\n\t\t\t\theaders.set(curKey, item)\n\t\t\t\tcurKey = null\n\t\t\t} else {\n\t\t\t\tcurKey = item\n\t\t\t}\n\t\t}\n\n\t\tthis.headers = headers\n\n\t\treturn this.headers.get(key)\n\t}\n\n\tjson(): object {\n\t\treturn JSON.parse(this.data || null)\n\t}\n\n\tjsonPassive(): object {\n\t\ttry {\n\t\t\treturn JSON.parse(this.data || null)\n\t\t} catch {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tstring(): string {\n\t\treturn this.data\n\t}\n}\n\nexport class Request {\n\tssl: boolean\n\thostname: string\n\tport: number\n\tsocketPath: string\n\tttl: number\n\tmethod: string\n\tpath: string\n\theaders: Map<string, string>\n\tdata: string\n\n\tconstructor() {\n\t\tthis.headers = new Map<string, string>()\n\t}\n\n\ttcp(host: string): Request {\n\t\tlet hosts = host.split(\"://\")\n\n\t\tthis.ssl = hosts[0] === \"https\"\n\n\t\thosts = hosts[1].split(\":\")\n\n\t\tif (hosts.length > 1) {\n\t\t\tthis.port = parseInt(hosts.pop(), 10)\n\t\t} else {\n\t\t\tthis.port = 80\n\t\t}\n\n\t\tthis.hostname = hosts.join(\":\")\n\n\t\treturn this\n\t}\n\n\tunix(path: string): Request {\n\t\tthis.socketPath = path\n\t\treturn this\n\t}\n\n\ttimeout(timeout: number) {\n\t\tthis.ttl = timeout * 1000\n\t}\n\n\tget(path: string): Request {\n\t\tthis.method = \"GET\"\n\t\tthis.path = path\n\t\treturn this\n\t}\n\n\tput(path: string): Request {\n\t\tthis.method = \"PUT\"\n\t\tthis.path = path\n\t\treturn this\n\t}\n\n\tpost(path: string): Request {\n\t\tthis.method = \"POST\"\n\t\tthis.path = path\n\t\treturn this\n\t}\n\n\tdelete(path: string): Request {\n\t\tthis.method = \"DELETE\"\n\t\tthis.path = path\n\t\treturn this\n\t}\n\n\tset(key: string, value: string): Request {\n\t\tthis.headers.set(key, value)\n\t\treturn this\n\t}\n\n\tsend(data: string|object): Request {\n\t\tif (typeof data === \"string\") {\n\t\t\tthis.data = data\n\t\t} else {\n\t\t\tthis.headers.set(\"Content-Type\", \"application/json\")\n\t\t\tthis.data = JSON.stringify(data)\n\t\t}\n\n\t\treturn this\n\t}\n\n\tparseError(wrapErr: Error, msg: string): Errors.RequestError {\n\t\tlet data: {[key: string]: any} = {}\n\n\t\tif (this.ssl !== undefined) {\n\t\t\tdata.ssl = this.ssl\n\t\t}\n\t\tif (this.hostname) {\n\t\t\tdata.hostname = this.hostname\n\t\t}\n\t\tif (this.port) {\n\t\t\tdata.port = this.port\n\t\t}\n\t\tif (this.method) {\n\t\t\tdata.method = this.method\n\t\t}\n\t\tif (this.path) {\n\t\t\tdata.path = this.path\n\t\t}\n\t\tif (this.ttl !== undefined) {\n\t\t\tdata.ttl = this.ttl\n\t\t}\n\n\t\treturn new Errors.RequestError(\n\t\t\twrapErr, msg, data)\n\t}\n\n\tend(): Promise<Response> {\n\t\treturn new Promise<Response>((resolve, reject): void => {\n\t\t\ttry {\n\t\t\t\tlet options: http.RequestOptions = {\n\t\t\t\t\tpath: this.path,\n\t\t\t\t\tmethod: this.method,\n\t\t\t\t\theaders: Object.fromEntries(this.headers)\n\t\t\t\t}\n\n\t\t\t\tif (this.socketPath) {\n\t\t\t\t\toptions.socketPath = this.socketPath\n\t\t\t\t} else {\n\t\t\t\t\toptions.hostname = this.hostname\n\t\t\t\t\toptions.port = this.port\n\t\t\t\t}\n\n\t\t\t\toptions.timeout = this.ttl || (DefaultTimeout * 1000)\n\n\t\t\t\tlet callback = (nodeResp: http.IncomingMessage) => {\n\t\t\t\t\tlet resp = new Response(nodeResp)\n\n\t\t\t\t\tnodeResp.on(\"data\", (data) => {\n\t\t\t\t\t\tif (data) {\n\t\t\t\t\t\t\tresp.data = data.toString()\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tnodeResp.on(\"end\", () => {\n\t\t\t\t\t\tresolve(resp)\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tlet req: http.ClientRequest\n\t\t\t\tif (this.ssl) {\n\t\t\t\t\treq = https.request(options, callback)\n\t\t\t\t} else {\n\t\t\t\t\treq = http.request(options, callback)\n\t\t\t\t}\n\n\t\t\t\treq.on(\"timeout\", () => {\n\t\t\t\t\tlet err = this.parseError(null, \"Request: Timeout error\")\n\t\t\t\t\treq.destroy(err)\n\t\t\t\t\tLogger.error(err)\n\t\t\t\t\treject(err)\n\t\t\t\t})\n\n\t\t\t\treq.on(\"error\", (err) => {\n\t\t\t\t\terr = this.parseError(err, \"Request:  Client error\")\n\t\t\t\t\tLogger.error(err)\n\t\t\t\t\treject(err)\n\t\t\t\t})\n\n\t\t\t\tif (this.data) {\n\t\t\t\t\treq.write(this.data)\n\t\t\t\t}\n\n\t\t\t\treq.end()\n\t\t\t} catch (err) {\n\t\t\t\terr = this.parseError(err, \"Request: Exception\")\n\t\t\t\tLogger.error(err)\n\t\t\t\treject(err)\n\t\t\t}\n\t\t})\n\t}\n}\n","import * as Auth from \"./Auth\";\nimport * as Request from \"./Request\"\nimport crypto from \"crypto\";\n\nexport function get(path: string): Request.Request {\n\tlet req = new Request.Request()\n\n\tif (Auth.unix) {\n\t\treq.unix(Auth.unixPath)\n\t} else {\n\t\treq.tcp(Auth.webHost)\n\t}\n\n\treq.get(path)\n\t\t.set(\"Auth-Token\", Auth.token)\n\t\t.set(\"User-Agent\", \"pritunl\")\n\n\treturn req\n}\n\nexport function put(path: string): Request.Request {\n\tlet req = new Request.Request()\n\n\tif (Auth.unix) {\n\t\treq.unix(Auth.unixPath)\n\t} else {\n\t\treq.tcp(Auth.webHost)\n\t}\n\n\treq.put(path)\n\t\t.set(\"Auth-Token\", Auth.token)\n\t\t.set(\"User-Agent\", \"pritunl\")\n\n\treturn req\n}\n\nexport function post(path: string): Request.Request {\n\tlet req = new Request.Request()\n\n\tif (Auth.unix) {\n\t\treq.unix(Auth.unixPath)\n\t} else {\n\t\treq.tcp(Auth.webHost)\n\t}\n\n\treq.post(path)\n\t\t.set(\"Auth-Token\", Auth.token)\n\t\t.set(\"User-Agent\", \"pritunl\")\n\n\treturn req\n}\n\nexport function del(path: string): Request.Request {\n\tlet req = new Request.Request()\n\n\tif (Auth.unix) {\n\t\treq.unix(Auth.unixPath)\n\t} else {\n\t\treq.tcp(Auth.webHost)\n\t}\n\n\treq.delete(path)\n\t\t.set(\"Auth-Token\", Auth.token)\n\t\t.set(\"User-Agent\", \"pritunl\")\n\n\treturn req\n}\n","/// <reference path=\"./References.d.ts\"/>\n\nexport class BaseError extends Error {\n\tname: string\n\tmessage: string\n\tstack: string\n\n\tconstructor(name: string, wrapErr: Error, message: string,\n\t\targs?: {[key: string]: any}) {\n\n\t\tsuper()\n\n\t\tif (args) {\n\t\t\tfor (let key in args) {\n\t\t\t\tmessage += \" \" + key + \"=\" + args[key]\n\t\t\t}\n\t\t}\n\n\t\tif (wrapErr) {\n\t\t\tmessage += '\\n' + wrapErr\n\t\t}\n\n\t\tthis.name = name\n\t\tthis.message = message\n\t\tif (wrapErr) {\n\t\t\tthis.stack = wrapErr.stack\n\t\t}\n\t}\n}\n\nexport class ReadError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"ReadError\", wrapErr, message, args)\n\t}\n}\n\nexport class WriteError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"WriteError\", wrapErr, message, args)\n\t}\n}\n\nexport class ParseError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"ParseError\", wrapErr, message, args)\n\t}\n}\n\nexport class RequestError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"RequestError\", wrapErr, message, args)\n\t}\n}\n\nexport class ExecError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"ExecError\", wrapErr, message, args)\n\t}\n}\n\nexport class UnknownError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, args?: {[key: string]: any}) {\n\t\tsuper(\"UnknownError\", wrapErr, message, args)\n\t}\n}\n\nexport class UnhandledError extends BaseError {\n\tconstructor(wrapErr: Error, message: string, origMessage: string,\n\t\torigStack: string) {\n\n\t\tsuper(\"UnhandledError\", wrapErr, message, {\n\t\t\tmessage: origMessage,\n\t\t\tstack: origStack,\n\t\t})\n\t\tthis.stack = origStack\n\t}\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:events\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:stream\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:string_decoder\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:path\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"assert\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:assert\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node:fs/promises\");","import EE from 'events'\nimport fs from 'fs'\nimport { Minipass } from 'minipass'\n\nconst writev = fs.writev\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nexport type ReadStreamOptions =\n  Minipass.Options<Minipass.ContiguousData> & {\n    fd?: number\n    readSize?: number\n    size?: number\n    autoClose?: boolean\n  }\n\nexport type ReadStreamEvents = Minipass.Events<Minipass.ContiguousData> & {\n  open: [fd: number]\n}\n\nexport class ReadStream extends Minipass<\n  Minipass.ContiguousData,\n  Buffer,\n  ReadStreamEvents\n> {\n  [_errored]: boolean = false;\n  [_fd]?: number;\n  [_path]: string;\n  [_readSize]: number;\n  [_reading]: boolean = false;\n  [_size]: number;\n  [_remain]: number;\n  [_autoClose]: boolean\n\n  constructor(path: string, opt: ReadStreamOptions) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string') {\n      throw new TypeError('path must be a string')\n    }\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16 * 1024 * 1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] =\n      typeof opt.autoClose === 'boolean' ? opt.autoClose : true\n\n    if (typeof this[_fd] === 'number') {\n      this[_read]()\n    } else {\n      this[_open]()\n    }\n  }\n\n  get fd() {\n    return this[_fd]\n  }\n\n  get path() {\n    return this[_path]\n  }\n\n  //@ts-ignore\n  write() {\n    throw new TypeError('this is a readable stream')\n  }\n\n  //@ts-ignore\n  end() {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open]() {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen](er?: NodeJS.ErrnoException | null, fd?: number) {\n    if (er) {\n      this[_onerror](er)\n    } else {\n      this[_fd] = fd\n      this.emit('open', fd as number)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf]() {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read]() {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* c8 ignore start */\n      if (buf.length === 0) {\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      }\n      /* c8 ignore stop */\n      fs.read(this[_fd] as number, buf, 0, buf.length, null, (er, br, b) =>\n        this[_onread](er, br, b),\n      )\n    }\n  }\n\n  [_onread](er?: NodeJS.ErrnoException | null, br?: number, buf?: Buffer) {\n    this[_reading] = false\n    if (er) {\n      this[_onerror](er)\n    } else if (this[_handleChunk](br as number, buf as Buffer)) {\n      this[_read]()\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = undefined\n      fs.close(fd, er =>\n        er ? this.emit('error', er) : this.emit('close'),\n      )\n    }\n  }\n\n  [_onerror](er: NodeJS.ErrnoException) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk](br: number, buf: Buffer) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0) {\n      ret = super.write(br < buf.length ? buf.subarray(0, br) : buf)\n    }\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit<Event extends keyof ReadStreamEvents>(\n    ev: Event,\n    ...args: ReadStreamEvents[Event]\n  ): boolean {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        return false\n\n      case 'drain':\n        if (typeof this[_fd] === 'number') {\n          this[_read]()\n        }\n        return false\n\n      case 'error':\n        if (this[_errored]) {\n          return false\n        }\n        this[_errored] = true\n        return super.emit(ev, ...args)\n\n      default:\n        return super.emit(ev, ...args)\n    }\n  }\n}\n\nexport class ReadStreamSync extends ReadStream {\n  [_open]() {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw) {\n        this[_close]()\n      }\n    }\n  }\n\n  [_read]() {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* c8 ignore start */\n          const br =\n            buf.length === 0\n              ? 0\n              : fs.readSync(this[_fd] as number, buf, 0, buf.length, null)\n          /* c8 ignore stop */\n          if (!this[_handleChunk](br, buf)) {\n            break\n          }\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw) {\n        this[_close]()\n      }\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = undefined\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nexport type WriteStreamOptions = {\n  fd?: number\n  autoClose?: boolean\n  mode?: number\n  captureRejections?: boolean\n  start?: number\n  flags?: string\n}\n\nexport class WriteStream extends EE {\n  readable: false = false\n  writable: boolean = true;\n  [_errored]: boolean = false;\n  [_writing]: boolean = false;\n  [_ended]: boolean = false;\n  [_queue]: Buffer[] = [];\n  [_needDrain]: boolean = false;\n  [_path]: string;\n  [_mode]: number;\n  [_autoClose]: boolean;\n  [_fd]?: number;\n  [_defaultFlag]: boolean;\n  [_flags]: string;\n  [_finished]: boolean = false;\n  [_pos]?: number\n\n  constructor(path: string, opt: WriteStreamOptions) {\n    opt = opt || {}\n    super(opt)\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : undefined\n    this[_autoClose] =\n      typeof opt.autoClose === 'boolean' ? opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags\n\n    if (this[_fd] === undefined) {\n      this[_open]()\n    }\n  }\n\n  emit(ev: string, ...args: any[]) {\n    if (ev === 'error') {\n      if (this[_errored]) {\n        return false\n      }\n      this[_errored] = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  get fd() {\n    return this[_fd]\n  }\n\n  get path() {\n    return this[_path]\n  }\n\n  [_onerror](er: NodeJS.ErrnoException) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open]() {\n    fs.open(this[_path], this[_flags], this[_mode], (er, fd) =>\n      this[_onopen](er, fd),\n    )\n  }\n\n  [_onopen](er?: null | NodeJS.ErrnoException, fd?: number) {\n    if (\n      this[_defaultFlag] &&\n      this[_flags] === 'r+' &&\n      er &&\n      er.code === 'ENOENT'\n    ) {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er) {\n      this[_onerror](er)\n    } else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      if (!this[_writing]) {\n        this[_flush]()\n      }\n    }\n  }\n\n  end(buf: string, enc?: BufferEncoding): this\n  end(buf?: Buffer, enc?: undefined): this\n  end(buf?: Buffer | string, enc?: BufferEncoding): this {\n    if (buf) {\n      //@ts-ignore\n      this.write(buf, enc)\n    }\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (\n      !this[_writing] &&\n      !this[_queue].length &&\n      typeof this[_fd] === 'number'\n    ) {\n      this[_onwrite](null, 0)\n    }\n    return this\n  }\n\n  write(buf: string, enc?: BufferEncoding): boolean\n  write(buf: Buffer, enc?: undefined): boolean\n  write(buf: Buffer | string, enc?: BufferEncoding): boolean {\n    if (typeof buf === 'string') {\n      buf = Buffer.from(buf, enc)\n    }\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === undefined || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write](buf: Buffer) {\n    fs.write(\n      this[_fd] as number,\n      buf,\n      0,\n      buf.length,\n      this[_pos],\n      (er, bw) => this[_onwrite](er, bw),\n    )\n  }\n\n  [_onwrite](er?: null | NodeJS.ErrnoException, bw?: number) {\n    if (er) {\n      this[_onerror](er)\n    } else {\n      if (this[_pos] !== undefined && typeof bw === 'number') {\n        this[_pos] += bw\n      }\n      if (this[_queue].length) {\n        this[_flush]()\n      } else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush]() {\n    if (this[_queue].length === 0) {\n      if (this[_ended]) {\n        this[_onwrite](null, 0)\n      }\n    } else if (this[_queue].length === 1) {\n      this[_write](this[_queue].pop() as Buffer)\n    } else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd] as number, iovec, this[_pos] as number, (er, bw) =>\n        this[_onwrite](er, bw),\n      )\n    }\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = undefined\n      fs.close(fd, er =>\n        er ? this.emit('error', er) : this.emit('close'),\n      )\n    }\n  }\n}\n\nexport class WriteStreamSync extends WriteStream {\n  [_open](): void {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else {\n          throw er\n        }\n      }\n    } else {\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n    }\n\n    this[_onopen](null, fd)\n  }\n\n  [_close]() {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = undefined\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write](buf: Buffer) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](\n        null,\n        fs.writeSync(this[_fd] as number, buf, 0, buf.length, this[_pos]),\n      )\n      threw = false\n    } finally {\n      if (threw) {\n        try {\n          this[_close]()\n        } catch {\n          // ok error\n        }\n      }\n    }\n  }\n}\n","const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'node:events'\nimport Stream from 'node:stream'\nimport { StringDecoder } from 'node:string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> =\n    | ObjectModeOptions\n    | (T extends string\n        ? EncodingOptions\n        : T extends Buffer\n        ? BufferOptions\n        : SharedOptions)\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args:\n      | [Minipass.ObjectModeOptions]\n      | (RType extends Buffer\n          ? [] | [Minipass.Options<RType>]\n          : [Minipass.Options<RType>])\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): this {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data as RType) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n","import { WriteStream, WriteStreamSync } from '@isaacs/fs-minipass'\nimport { Minipass } from 'minipass'\nimport path from 'node:path'\nimport { list } from './list.js'\nimport { makeCommand } from './make-command.js'\nimport {\n  TarOptions,\n  TarOptionsFile,\n  TarOptionsSync,\n  TarOptionsSyncFile,\n} from './options.js'\nimport { Pack, PackSync } from './pack.js'\n\nconst createFileSync = (opt: TarOptionsSyncFile, files: string[]) => {\n  const p = new PackSync(opt)\n  const stream = new WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream as unknown as Minipass.Writable)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt: TarOptionsFile, files: string[]) => {\n  const p = new Pack(opt)\n  const stream = new WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream as unknown as Minipass.Writable)\n\n  const promise = new Promise<void>((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return promise\n}\n\nconst addFilesSync = (p: PackSync, files: string[]) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      list({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onReadEntry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = async (\n  p: Pack,\n  files: string[],\n): Promise<void> => {\n  for (let i = 0; i < files.length; i++) {\n    const file = String(files[i])\n    if (file.charAt(0) === '@') {\n      await list({\n        file: path.resolve(String(p.cwd), file.slice(1)),\n        noResume: true,\n        onReadEntry: entry => {\n          p.add(entry)\n        },\n      })\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt: TarOptionsSync, files: string[]) => {\n  const p = new PackSync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst createAsync = (opt: TarOptions, files: string[]) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n\nexport const create = makeCommand(\n  createFileSync,\n  createFile,\n  createSync,\n  createAsync,\n  (_opt, files) => {\n    if (!files?.length) {\n      throw new TypeError('no paths specified to add to archive')\n    }\n  },\n)\n","// tar -t\nimport * as fsm from '@isaacs/fs-minipass'\nimport fs from 'node:fs'\nimport { dirname, parse } from 'path'\nimport { makeCommand } from './make-command.js'\nimport {\n  TarOptions,\n  TarOptionsFile,\n  TarOptionsSyncFile,\n} from './options.js'\nimport { Parser } from './parse.js'\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js'\n\nconst onReadEntryFunction = (opt: TarOptions) => {\n  const onReadEntry = opt.onReadEntry\n  opt.onReadEntry =\n    onReadEntry ?\n      e => {\n        onReadEntry(e)\n        e.resume()\n      }\n    : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nexport const filesFilter = (opt: TarOptions, files: string[]) => {\n  const map = new Map<string, boolean>(\n    files.map(f => [stripTrailingSlashes(f), true]),\n  )\n  const filter = opt.filter\n\n  const mapHas = (file: string, r: string = ''): boolean => {\n    const root = r || parse(file).root || '.'\n    let ret: boolean\n    if (file === root) ret = false\n    else {\n      const m = map.get(file)\n      if (m !== undefined) {\n        ret = m\n      } else {\n        ret = mapHas(dirname(file), root)\n      }\n    }\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter =\n    filter ?\n      (file, entry) =>\n        filter(file, entry) && mapHas(stripTrailingSlashes(file))\n    : file => mapHas(stripTrailingSlashes(file))\n}\n\nconst listFileSync = (opt: TarOptionsSyncFile) => {\n  const p = new Parser(opt)\n  const file = opt.file\n  let fd: number | undefined\n  try {\n    fd = fs.openSync(file, 'r')\n    const stat: fs.Stats = fs.fstatSync(fd)\n    const readSize: number = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      const buf = Buffer.allocUnsafe(stat.size)\n      const read = fs.readSync(fd, buf, 0, stat.size, 0)\n      p.end(read === buf.byteLength ? buf : buf.subarray(0, read))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        if (bytesRead === 0) break\n        pos += bytesRead\n        p.write(buf.subarray(0, bytesRead))\n      }\n      p.end()\n    }\n  } finally {\n    if (typeof fd === 'number') {\n      try {\n        fs.closeSync(fd)\n        /* c8 ignore next */\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (\n  opt: TarOptionsFile,\n  _files: string[],\n): Promise<void> => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise<void>((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return p\n}\n\nexport const list = makeCommand(\n  listFileSync,\n  listFile,\n  opt => new Parser(opt) as Parser & { sync: true },\n  opt => new Parser(opt),\n  (opt, files) => {\n    if (files?.length) filesFilter(opt, files)\n    if (!opt.noResume) onReadEntryFunction(opt)\n  },\n)\n","// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nimport { type GzipOptions, type ZlibOptions } from 'minizlib'\nimport { type Stats } from 'node:fs'\nimport { type ReadEntry } from './read-entry.js'\nimport { type WarnData } from './warn-method.js'\nimport { WriteEntry } from './write-entry.js'\n\nconst argmap = new Map<keyof TarOptionsWithAliases, keyof TarOptions>(\n  [\n    ['C', 'cwd'],\n    ['f', 'file'],\n    ['z', 'gzip'],\n    ['P', 'preservePaths'],\n    ['U', 'unlink'],\n    ['strip-components', 'strip'],\n    ['stripComponents', 'strip'],\n    ['keep-newer', 'newer'],\n    ['keepNewer', 'newer'],\n    ['keep-newer-files', 'newer'],\n    ['keepNewerFiles', 'newer'],\n    ['k', 'keep'],\n    ['keep-existing', 'keep'],\n    ['keepExisting', 'keep'],\n    ['m', 'noMtime'],\n    ['no-mtime', 'noMtime'],\n    ['p', 'preserveOwner'],\n    ['L', 'follow'],\n    ['h', 'follow'],\n    ['onentry', 'onReadEntry'],\n  ],\n)\n\n/**\n * The options that can be provided to tar commands.\n *\n * Note that some of these are only relevant for certain commands, since\n * they are specific to reading or writing.\n *\n * Aliases are provided in the {@link TarOptionsWithAliases} type.\n */\nexport interface TarOptions {\n  //////////////////////////\n  // shared options\n\n  /**\n   * Perform all I/O operations synchronously. If the stream is ended\n   * immediately, then it will be processed entirely synchronously.\n   */\n  sync?: boolean\n\n  /**\n   * The tar file to be read and/or written. When this is set, a stream\n   * is not returned. Asynchronous commands will return a promise indicating\n   * when the operation is completed, and synchronous commands will return\n   * immediately.\n   */\n  file?: string\n\n  /**\n   * Treat warnings as crash-worthy errors. Defaults false.\n   */\n  strict?: boolean\n\n  /**\n   * The effective current working directory for this tar command\n   */\n  cwd?: string\n\n  /**\n   * When creating a tar archive, this can be used to compress it as well.\n   * Set to `true` to use the default gzip options, or customize them as\n   * needed.\n   *\n   * When reading, if this is unset, then the compression status will be\n   * inferred from the archive data. This is generally best, unless you are\n   * sure of the compression settings in use to create the archive, and want to\n   * fail if the archive doesn't match expectations.\n   */\n  gzip?: boolean | GzipOptions\n\n  /**\n   * When creating archives, preserve absolute and `..` paths in the archive,\n   * rather than sanitizing them under the cwd.\n   *\n   * When extracting, allow absolute paths, paths containing `..`, and\n   * extracting through symbolic links. By default, the root `/` is stripped\n   * from absolute paths (eg, turning `/x/y/z` into `x/y/z`), paths containing\n   * `..` are not extracted, and any file whose location would be modified by a\n   * symbolic link is not extracted.\n   *\n   * **WARNING** This is almost always unsafe, and must NEVER be used on\n   * archives from untrusted sources, such as user input, and every entry must\n   * be validated to ensure it is safe to write. Even if the input is not\n   * malicious, mistakes can cause a lot of damage!\n   */\n  preservePaths?: boolean\n\n  /**\n   * When extracting, do not set the `mtime` value for extracted entries to\n   * match the `mtime` in the archive.\n   *\n   * When creating archives, do not store the `mtime` value in the entry. Note\n   * that this prevents properly using other mtime-based features (such as\n   * `tar.update` or the `newer` option) with the resulting archive.\n   */\n  noMtime?: boolean\n\n  /**\n   * Set to `true` or an object with settings for `zlib.BrotliCompress()` to\n   * create a brotli-compressed archive\n   *\n   * When extracting, this will cause the archive to be treated as a\n   * brotli-compressed file if set to `true` or a ZlibOptions object.\n   *\n   * If set `false`, then brotli options will not be used.\n   *\n   * If this, the `gzip`, and `zstd` options are left `undefined`, then tar\n   * will attempt to infer the brotli compression status, but can only do so\n   * based on the filename. If the filename ends in `.tbr` or `.tar.br`, and\n   * the first 512 bytes are not a valid tar header, then brotli decompression\n   * will be attempted.\n   */\n  brotli?: boolean | ZlibOptions\n\n  /**\n   * Set to `true` or an object with settings for `zstd.compress()` to\n   * create a zstd-compressed archive\n   *\n   * When extracting, this will cause the archive to be treated as a\n   * zstd-compressed file if set to `true` or a ZlibOptions object.\n   *\n   * If set `false`, then zstd options will not be used.\n   *\n   * If this, the `gzip`, and `brotli` options are left `undefined`, then tar\n   * will attempt to infer the zstd compression status, but can only do so\n   * based on the filename. If the filename ends in `.tzst` or `.tar.zst`, and\n   * the first 512 bytes are not a valid tar header, then zstd decompression\n   * will be attempted.\n   */\n  zstd?: boolean | ZlibOptions\n\n  /**\n   * A function that is called with `(path, stat)` when creating an archive, or\n   * `(path, entry)` when extracting. Return true to process the file/entry, or\n   * false to exclude it.\n   */\n  filter?: (path: string, entry: Stats | ReadEntry) => boolean\n\n  /**\n   * A function that gets called for any warning encountered.\n   *\n   * Note: if `strict` is set, then the warning will throw, and this method\n   * will not be called.\n   */\n  onwarn?: (code: string, message: string, data: WarnData) => any\n\n  //////////////////////////\n  // extraction options\n\n  /**\n   * When extracting, unlink files before creating them. Without this option,\n   * tar overwrites existing files, which preserves existing hardlinks. With\n   * this option, existing hardlinks will be broken, as will any symlink that\n   * would affect the location of an extracted file.\n   */\n  unlink?: boolean\n\n  /**\n   * When extracting, strip the specified number of path portions from the\n   * entry path. For example, with `{strip: 2}`, the entry `a/b/c/d` would be\n   * extracted to `{cwd}/c/d`.\n   *\n   * Any entry whose entire path is stripped will be excluded.\n   */\n  strip?: number\n\n  /**\n   * When extracting, keep the existing file on disk if it's newer than the\n   * file in the archive.\n   */\n  newer?: boolean\n\n  /**\n   * When extracting, do not overwrite existing files at all.\n   */\n  keep?: boolean\n\n  /**\n   * When extracting, set the `uid` and `gid` of extracted entries to the `uid`\n   * and `gid` fields in the archive. Defaults to true when run as root, and\n   * false otherwise.\n   *\n   * If false, then files and directories will be set with the owner and group\n   * of the user running the process. This is similar to `-p` in `tar(1)`, but\n   * ACLs and other system-specific data is never unpacked in this\n   * implementation, and modes are set by default already.\n   */\n  preserveOwner?: boolean\n\n  /**\n   * The maximum depth of subfolders to extract into. This defaults to 1024.\n   * Anything deeper than the limit will raise a warning and skip the entry.\n   * Set to `Infinity` to remove the limitation.\n   */\n  maxDepth?: number\n\n  /**\n   * When extracting, force all created files and directories, and all\n   * implicitly created directories, to be owned by the specified user id,\n   * regardless of the `uid` field in the archive.\n   *\n   * Cannot be used along with `preserveOwner`. Requires also setting the `gid`\n   * option.\n   */\n  uid?: number\n\n  /**\n   * When extracting, force all created files and directories, and all\n   * implicitly created directories, to be owned by the specified group id,\n   * regardless of the `gid` field in the archive.\n   *\n   * Cannot be used along with `preserveOwner`. Requires also setting the `uid`\n   * option.\n   */\n  gid?: number\n\n  /**\n   * When extracting, provide a function that takes an `entry` object, and\n   * returns a stream, or any falsey value. If a stream is provided, then that\n   * stream's data will be written instead of the contents of the archive\n   * entry. If a falsey value is provided, then the entry is written to disk as\n   * normal.\n   *\n   * To exclude items from extraction, use the `filter` option.\n   *\n   * Note that using an asynchronous stream type with the `transform` option\n   * will cause undefined behavior in synchronous extractions.\n   * [MiniPass](http://npm.im/minipass)-based streams are designed for this use\n   * case.\n   */\n  transform?: (entry: ReadEntry) => any\n\n  /**\n   * Call `chmod()` to ensure that extracted files match the entry's mode\n   * field. Without this field set, all mode fields in archive entries are a\n   * best effort attempt only.\n   *\n   * Setting this necessitates a call to the deprecated `process.umask()`\n   * method to determine the default umask value, unless a `processUmask`\n   * config is provided as well.\n   *\n   * If not set, tar will attempt to create file system entries with whatever\n   * mode is provided, and let the implicit process `umask` apply normally, but\n   * if a file already exists to be written to, then its existing mode will not\n   * be modified.\n   *\n   * When setting `chmod: true`, it is highly recommend to set the\n   * {@link TarOptions#processUmask} option as well, to avoid the call to the\n   * deprecated (and thread-unsafe) `process.umask()` method.\n   */\n  chmod?: boolean\n\n  /**\n   * When setting the {@link TarOptions#chmod} option to `true`, you may\n   * provide a value here to avoid having to call the deprecated and\n   * thread-unsafe `process.umask()` method.\n   *\n   * This has no effect with `chmod` is not set to true, as mode values are not\n   * set explicitly anyway. If `chmod` is set to `true`, and a value is not\n   * provided here, then `process.umask()` must be called, which will result in\n   * deprecation warnings.\n   *\n   * The most common values for this are `0o22` (resulting in directories\n   * created with mode `0o755` and files with `0o644` by default) and `0o2`\n   * (resulting in directores created with mode `0o775` and files `0o664`, so\n   * they are group-writable).\n   */\n  processUmask?: number\n\n  //////////////////////////\n  // archive creation options\n\n  /**\n   * When parsing/listing archives, `entry` streams are by default resumed\n   * (set into \"flowing\" mode) immediately after the call to `onReadEntry()`.\n   * Set `noResume: true` to suppress this behavior.\n   *\n   * Note that when this is set, the stream will never complete until the\n   * data is consumed somehow.\n   *\n   * Set automatically in extract operations, since the entry is piped to\n   * a file system entry right away. Only relevant when parsing.\n   */\n  noResume?: boolean\n\n  /**\n   * When creating, updating, or replacing within archives, this method will\n   * be called with each WriteEntry that is created.\n   */\n  onWriteEntry?: (entry: WriteEntry) => any\n\n  /**\n   * When extracting or listing archives, this method will be called with\n   * each entry that is not excluded by a `filter`.\n   *\n   * Important when listing archives synchronously from a file, because there\n   * is otherwise no way to interact with the data!\n   */\n  onReadEntry?: (entry: ReadEntry) => any\n\n  /**\n   * Pack the targets of symbolic links rather than the link itself.\n   */\n  follow?: boolean\n\n  /**\n   * When creating archives, omit any metadata that is system-specific:\n   * `ctime`, `atime`, `uid`, `gid`, `uname`, `gname`, `dev`, `ino`, and\n   * `nlink`. Note that `mtime` is still included, because this is necessary\n   * for other time-based operations such as `tar.update`. Additionally, `mode`\n   * is set to a \"reasonable default\" for mose unix systems, based on an\n   * effective `umask` of `0o22`.\n   *\n   * This also defaults the `portable` option in the gzip configs when creating\n   * a compressed archive, in order to produce deterministic archives that are\n   * not operating-system specific.\n   */\n  portable?: boolean\n\n  /**\n   * When creating archives, do not recursively archive the contents of\n   * directories. By default, archiving a directory archives all of its\n   * contents as well.\n   */\n  noDirRecurse?: boolean\n\n  /**\n   * Suppress Pax extended headers when creating archives. Note that this means\n   * long paths and linkpaths will be truncated, and large or negative numeric\n   * values may be interpreted incorrectly.\n   */\n  noPax?: boolean\n\n  /**\n   * Set to a `Date` object to force a specific `mtime` value for everything\n   * written to an archive.\n   *\n   * This is useful when creating archives that are intended to be\n   * deterministic based on their contents, irrespective of the file's last\n   * modification time.\n   *\n   * Overridden by `noMtime`.\n   */\n  mtime?: Date\n\n  /**\n   * A path portion to prefix onto the entries added to an archive.\n   */\n  prefix?: string\n\n  /**\n   * The mode to set on any created file archive, defaults to 0o666\n   * masked by the process umask, often resulting in 0o644.\n   *\n   * This does *not* affect the mode fields of individual entries, or the\n   * mode status of extracted entries on the filesystem.\n   */\n  mode?: number\n\n  //////////////////////////\n  // internal options\n\n  /**\n   * A cache of mtime values, to avoid having to stat the same file repeatedly.\n   *\n   * @internal\n   */\n  mtimeCache?: Map<string, Date>\n\n  /**\n   * maximum buffer size for `fs.read()` operations.\n   *\n   * @internal\n   */\n  maxReadSize?: number\n\n  /**\n   * Filter modes of entries being unpacked, like `process.umask()`\n   *\n   * @internal\n   */\n  umask?: number\n\n  /**\n   * Default mode for directories. Used for all implicitly created directories,\n   * and any directories in the archive that do not have a mode field.\n   *\n   * @internal\n   */\n  dmode?: number\n\n  /**\n   * default mode for files\n   *\n   * @internal\n   */\n  fmode?: number\n\n  /**\n   * Map that tracks which directories already exist, for extraction\n   *\n   * @internal\n   */\n  dirCache?: Map<string, boolean>\n  /**\n   * maximum supported size of meta entries. Defaults to 1MB\n   *\n   * @internal\n   */\n  maxMetaEntrySize?: number\n\n  /**\n   * A Map object containing the device and inode value for any file whose\n   * `nlink` value is greater than 1, to identify hard links when creating\n   * archives.\n   *\n   * @internal\n   */\n  linkCache?: Map<LinkCacheKey, string>\n\n  /**\n   * A map object containing the results of `fs.readdir()` calls.\n   *\n   * @internal\n   */\n  readdirCache?: Map<string, string[]>\n\n  /**\n   * A cache of all `lstat` results, for use in creating archives.\n   *\n   * @internal\n   */\n  statCache?: Map<string, Stats>\n\n  /**\n   * Number of concurrent jobs to run when creating archives.\n   *\n   * Defaults to 4.\n   *\n   * @internal\n   */\n  jobs?: number\n\n  /**\n   * Automatically set to true on Windows systems.\n   *\n   * When extracting, causes behavior where filenames containing `<|>?:`\n   * characters are converted to windows-compatible escape sequences in the\n   * created filesystem entries.\n   *\n   * When packing, causes behavior where paths replace `\\` with `/`, and\n   * filenames containing the windows-compatible escaped forms of `<|>?:` are\n   * converted to actual `<|>?:` characters in the archive.\n   *\n   * @internal\n   */\n  win32?: boolean\n\n  /**\n   * For `WriteEntry` objects, the absolute path to the entry on the\n   * filesystem. By default, this is `resolve(cwd, entry.path)`, but it can be\n   * overridden explicitly.\n   *\n   * @internal\n   */\n  absolute?: string\n\n  /**\n   * Used with Parser stream interface, to attach and take over when the\n   * stream is completely parsed. If this is set, then the prefinish,\n   * finish, and end events will not fire, and are the responsibility of\n   * the ondone method to emit properly.\n   *\n   * @internal\n   */\n  ondone?: () => void\n\n  /**\n   * Mostly for testing, but potentially useful in some cases.\n   * Forcibly trigger a chown on every entry, no matter what.\n   */\n  forceChown?: boolean\n\n  /**\n   * ambiguous deprecated name for {@link onReadEntry}\n   *\n   * @deprecated\n   */\n  onentry?: (entry: ReadEntry) => any\n}\n\nexport type TarOptionsSync = TarOptions & { sync: true }\nexport type TarOptionsAsync = TarOptions & { sync?: false }\nexport type TarOptionsFile = TarOptions & { file: string }\nexport type TarOptionsNoFile = TarOptions & { file?: undefined }\nexport type TarOptionsSyncFile = TarOptionsSync & TarOptionsFile\nexport type TarOptionsAsyncFile = TarOptionsAsync & TarOptionsFile\nexport type TarOptionsSyncNoFile = TarOptionsSync & TarOptionsNoFile\nexport type TarOptionsAsyncNoFile = TarOptionsAsync & TarOptionsNoFile\n\nexport type LinkCacheKey = `${number}:${number}`\n\nexport interface TarOptionsWithAliases extends TarOptions {\n  /**\n   * The effective current working directory for this tar command\n   */\n  C?: TarOptions['cwd']\n  /**\n   * The tar file to be read and/or written. When this is set, a stream\n   * is not returned. Asynchronous commands will return a promise indicating\n   * when the operation is completed, and synchronous commands will return\n   * immediately.\n   */\n  f?: TarOptions['file']\n  /**\n   * When creating a tar archive, this can be used to compress it as well.\n   * Set to `true` to use the default gzip options, or customize them as\n   * needed.\n   *\n   * When reading, if this is unset, then the compression status will be\n   * inferred from the archive data. This is generally best, unless you are\n   * sure of the compression settings in use to create the archive, and want to\n   * fail if the archive doesn't match expectations.\n   */\n  z?: TarOptions['gzip']\n  /**\n   * When creating archives, preserve absolute and `..` paths in the archive,\n   * rather than sanitizing them under the cwd.\n   *\n   * When extracting, allow absolute paths, paths containing `..`, and\n   * extracting through symbolic links. By default, the root `/` is stripped\n   * from absolute paths (eg, turning `/x/y/z` into `x/y/z`), paths containing\n   * `..` are not extracted, and any file whose location would be modified by a\n   * symbolic link is not extracted.\n   *\n   * **WARNING** This is almost always unsafe, and must NEVER be used on\n   * archives from untrusted sources, such as user input, and every entry must\n   * be validated to ensure it is safe to write. Even if the input is not\n   * malicious, mistakes can cause a lot of damage!\n   */\n  P?: TarOptions['preservePaths']\n  /**\n   * When extracting, unlink files before creating them. Without this option,\n   * tar overwrites existing files, which preserves existing hardlinks. With\n   * this option, existing hardlinks will be broken, as will any symlink that\n   * would affect the location of an extracted file.\n   */\n  U?: TarOptions['unlink']\n  /**\n   * When extracting, strip the specified number of path portions from the\n   * entry path. For example, with `{strip: 2}`, the entry `a/b/c/d` would be\n   * extracted to `{cwd}/c/d`.\n   */\n  'strip-components'?: TarOptions['strip']\n  /**\n   * When extracting, strip the specified number of path portions from the\n   * entry path. For example, with `{strip: 2}`, the entry `a/b/c/d` would be\n   * extracted to `{cwd}/c/d`.\n   */\n  stripComponents?: TarOptions['strip']\n  /**\n   * When extracting, keep the existing file on disk if it's newer than the\n   * file in the archive.\n   */\n  'keep-newer'?: TarOptions['newer']\n  /**\n   * When extracting, keep the existing file on disk if it's newer than the\n   * file in the archive.\n   */\n  keepNewer?: TarOptions['newer']\n  /**\n   * When extracting, keep the existing file on disk if it's newer than the\n   * file in the archive.\n   */\n  'keep-newer-files'?: TarOptions['newer']\n  /**\n   * When extracting, keep the existing file on disk if it's newer than the\n   * file in the archive.\n   */\n  keepNewerFiles?: TarOptions['newer']\n  /**\n   * When extracting, do not overwrite existing files at all.\n   */\n  k?: TarOptions['keep']\n  /**\n   * When extracting, do not overwrite existing files at all.\n   */\n  'keep-existing'?: TarOptions['keep']\n  /**\n   * When extracting, do not overwrite existing files at all.\n   */\n  keepExisting?: TarOptions['keep']\n  /**\n   * When extracting, do not set the `mtime` value for extracted entries to\n   * match the `mtime` in the archive.\n   *\n   * When creating archives, do not store the `mtime` value in the entry. Note\n   * that this prevents properly using other mtime-based features (such as\n   * `tar.update` or the `newer` option) with the resulting archive.\n   */\n  m?: TarOptions['noMtime']\n  /**\n   * When extracting, do not set the `mtime` value for extracted entries to\n   * match the `mtime` in the archive.\n   *\n   * When creating archives, do not store the `mtime` value in the entry. Note\n   * that this prevents properly using other mtime-based features (such as\n   * `tar.update` or the `newer` option) with the resulting archive.\n   */\n  'no-mtime'?: TarOptions['noMtime']\n  /**\n   * When extracting, set the `uid` and `gid` of extracted entries to the `uid`\n   * and `gid` fields in the archive. Defaults to true when run as root, and\n   * false otherwise.\n   *\n   * If false, then files and directories will be set with the owner and group\n   * of the user running the process. This is similar to `-p` in `tar(1)`, but\n   * ACLs and other system-specific data is never unpacked in this\n   * implementation, and modes are set by default already.\n   */\n  p?: TarOptions['preserveOwner']\n  /**\n   * Pack the targets of symbolic links rather than the link itself.\n   */\n  L?: TarOptions['follow']\n  /**\n   * Pack the targets of symbolic links rather than the link itself.\n   */\n  h?: TarOptions['follow']\n\n  /**\n   * Deprecated option. Set explicitly false to set `chmod: true`. Ignored\n   * if {@link TarOptions#chmod} is set to any boolean value.\n   *\n   * @deprecated\n   */\n  noChmod?: boolean\n}\n\nexport type TarOptionsWithAliasesSync = TarOptionsWithAliases & {\n  sync: true\n}\nexport type TarOptionsWithAliasesAsync = TarOptionsWithAliases & {\n  sync?: false\n}\nexport type TarOptionsWithAliasesFile =\n  | (TarOptionsWithAliases & {\n      file: string\n    })\n  | (TarOptionsWithAliases & { f: string })\nexport type TarOptionsWithAliasesSyncFile =\n  TarOptionsWithAliasesSync & TarOptionsWithAliasesFile\nexport type TarOptionsWithAliasesAsyncFile =\n  TarOptionsWithAliasesAsync & TarOptionsWithAliasesFile\n\nexport type TarOptionsWithAliasesNoFile = TarOptionsWithAliases & {\n  f?: undefined\n  file?: undefined\n}\n\nexport type TarOptionsWithAliasesSyncNoFile =\n  TarOptionsWithAliasesSync & TarOptionsWithAliasesNoFile\nexport type TarOptionsWithAliasesAsyncNoFile =\n  TarOptionsWithAliasesAsync & TarOptionsWithAliasesNoFile\n\nexport const isSyncFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsSyncFile => !!o.sync && !!o.file\nexport const isAsyncFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsAsyncFile => !o.sync && !!o.file\nexport const isSyncNoFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsSyncNoFile => !!o.sync && !o.file\nexport const isAsyncNoFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsAsyncNoFile => !o.sync && !o.file\nexport const isSync = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsSync => !!o.sync\nexport const isAsync = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsAsync => !o.sync\nexport const isFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsFile => !!o.file\nexport const isNoFile = <O extends TarOptions>(\n  o: O,\n): o is O & TarOptionsNoFile => !o.file\n\nconst dealiasKey = (\n  k: keyof TarOptionsWithAliases,\n): keyof TarOptions => {\n  const d = argmap.get(k)\n  if (d) return d\n  return k as keyof TarOptions\n}\n\nexport const dealias = (\n  opt: TarOptionsWithAliases = {},\n): TarOptions => {\n  if (!opt) return {}\n  const result: Record<string, any> = {}\n  for (const [key, v] of Object.entries(opt) as [\n    keyof TarOptionsWithAliases,\n    any,\n  ][]) {\n    // TS doesn't know that aliases are going to always be the same type\n    const k = dealiasKey(key)\n    result[k] = v\n  }\n  // affordance for deprecated noChmod -> chmod\n  if (result.chmod === undefined && result.noChmod === false) {\n    result.chmod = true\n  }\n  delete result.noChmod\n  return result as TarOptions\n}\n","import {\n  dealias,\n  isAsyncFile,\n  isAsyncNoFile,\n  isSyncFile,\n  isSyncNoFile,\n  TarOptions,\n  TarOptionsAsyncFile,\n  TarOptionsAsyncNoFile,\n  TarOptionsSyncFile,\n  TarOptionsSyncNoFile,\n  TarOptionsWithAliases,\n  TarOptionsWithAliasesAsync,\n  TarOptionsWithAliasesAsyncFile,\n  TarOptionsWithAliasesAsyncNoFile,\n  TarOptionsWithAliasesFile,\n  TarOptionsWithAliasesNoFile,\n  TarOptionsWithAliasesSync,\n  TarOptionsWithAliasesSyncFile,\n  TarOptionsWithAliasesSyncNoFile,\n} from './options.js'\n\nexport type CB = (er?: Error) => any\n\nexport type TarCommand<\n  AsyncClass,\n  SyncClass extends { sync: true },\n> = {\n  // async and no file specified\n  (): AsyncClass\n  (opt: TarOptionsWithAliasesAsyncNoFile): AsyncClass\n  (entries: string[]): AsyncClass\n  (\n    opt: TarOptionsWithAliasesAsyncNoFile,\n    entries: string[],\n  ): AsyncClass\n} & {\n  // sync and no file\n  (opt: TarOptionsWithAliasesSyncNoFile): SyncClass\n  (opt: TarOptionsWithAliasesSyncNoFile, entries: string[]): SyncClass\n} & {\n  // async and file\n  (opt: TarOptionsWithAliasesAsyncFile): Promise<void>\n  (\n    opt: TarOptionsWithAliasesAsyncFile,\n    entries: string[],\n  ): Promise<void>\n  (opt: TarOptionsWithAliasesAsyncFile, cb: CB): Promise<void>\n  (\n    opt: TarOptionsWithAliasesAsyncFile,\n    entries: string[],\n    cb: CB,\n  ): Promise<void>\n} & {\n  // sync and file\n  (opt: TarOptionsWithAliasesSyncFile): void\n  (opt: TarOptionsWithAliasesSyncFile, entries: string[]): void\n} & {\n  // sync, maybe file\n  (opt: TarOptionsWithAliasesSync): typeof opt extends (\n    TarOptionsWithAliasesFile\n  ) ?\n    void\n  : typeof opt extends TarOptionsWithAliasesNoFile ? SyncClass\n  : void | SyncClass\n  (\n    opt: TarOptionsWithAliasesSync,\n    entries: string[],\n  ): typeof opt extends TarOptionsWithAliasesFile ? void\n  : typeof opt extends TarOptionsWithAliasesNoFile ? SyncClass\n  : void | SyncClass\n} & {\n  // async, maybe file\n  (opt: TarOptionsWithAliasesAsync): typeof opt extends (\n    TarOptionsWithAliasesFile\n  ) ?\n    Promise<void>\n  : typeof opt extends TarOptionsWithAliasesNoFile ? AsyncClass\n  : Promise<void> | AsyncClass\n  (\n    opt: TarOptionsWithAliasesAsync,\n    entries: string[],\n  ): typeof opt extends TarOptionsWithAliasesFile ? Promise<void>\n  : typeof opt extends TarOptionsWithAliasesNoFile ? AsyncClass\n  : Promise<void> | AsyncClass\n  (opt: TarOptionsWithAliasesAsync, cb: CB): Promise<void>\n  (\n    opt: TarOptionsWithAliasesAsync,\n    entries: string[],\n    cb: CB,\n  ): typeof opt extends TarOptionsWithAliasesFile ? Promise<void>\n  : typeof opt extends TarOptionsWithAliasesNoFile ? never\n  : Promise<void>\n} & {\n  // maybe sync, file\n  (opt: TarOptionsWithAliasesFile): Promise<void> | void\n  (\n    opt: TarOptionsWithAliasesFile,\n    entries: string[],\n  ): typeof opt extends TarOptionsWithAliasesSync ? void\n  : typeof opt extends TarOptionsWithAliasesAsync ? Promise<void>\n  : Promise<void> | void\n  (opt: TarOptionsWithAliasesFile, cb: CB): Promise<void>\n  (\n    opt: TarOptionsWithAliasesFile,\n    entries: string[],\n    cb: CB,\n  ): typeof opt extends TarOptionsWithAliasesSync ? never\n  : typeof opt extends TarOptionsWithAliasesAsync ? Promise<void>\n  : Promise<void>\n} & {\n  // maybe sync, no file\n  (opt: TarOptionsWithAliasesNoFile): typeof opt extends (\n    TarOptionsWithAliasesSync\n  ) ?\n    SyncClass\n  : typeof opt extends TarOptionsWithAliasesAsync ? AsyncClass\n  : SyncClass | AsyncClass\n  (\n    opt: TarOptionsWithAliasesNoFile,\n    entries: string[],\n  ): typeof opt extends TarOptionsWithAliasesSync ? SyncClass\n  : typeof opt extends TarOptionsWithAliasesAsync ? AsyncClass\n  : SyncClass | AsyncClass\n} & {\n  // maybe sync, maybe file\n  (opt: TarOptionsWithAliases): typeof opt extends (\n    TarOptionsWithAliasesFile\n  ) ?\n    typeof opt extends TarOptionsWithAliasesSync ? void\n    : typeof opt extends TarOptionsWithAliasesAsync ? Promise<void>\n    : void | Promise<void>\n  : typeof opt extends TarOptionsWithAliasesNoFile ?\n    typeof opt extends TarOptionsWithAliasesSync ? SyncClass\n    : typeof opt extends TarOptionsWithAliasesAsync ? AsyncClass\n    : SyncClass | AsyncClass\n  : typeof opt extends TarOptionsWithAliasesSync ? SyncClass | void\n  : typeof opt extends TarOptionsWithAliasesAsync ?\n    AsyncClass | Promise<void>\n  : SyncClass | void | AsyncClass | Promise<void>\n} & {\n  // extras\n  syncFile: (opt: TarOptionsSyncFile, entries: string[]) => void\n  asyncFile: (\n    opt: TarOptionsAsyncFile,\n    entries: string[],\n    cb?: CB,\n  ) => Promise<void>\n  syncNoFile: (\n    opt: TarOptionsSyncNoFile,\n    entries: string[],\n  ) => SyncClass\n  asyncNoFile: (\n    opt: TarOptionsAsyncNoFile,\n    entries: string[],\n  ) => AsyncClass\n  validate?: (opt: TarOptions, entries?: string[]) => void\n}\n\nexport const makeCommand = <\n  AsyncClass,\n  SyncClass extends { sync: true },\n>(\n  syncFile: (opt: TarOptionsSyncFile, entries: string[]) => void,\n  asyncFile: (\n    opt: TarOptionsAsyncFile,\n    entries: string[],\n    cb?: CB,\n  ) => Promise<void>,\n  syncNoFile: (\n    opt: TarOptionsSyncNoFile,\n    entries: string[],\n  ) => SyncClass,\n  asyncNoFile: (\n    opt: TarOptionsAsyncNoFile,\n    entries: string[],\n  ) => AsyncClass,\n  validate?: (opt: TarOptions, entries?: string[]) => void,\n): TarCommand<AsyncClass, SyncClass> => {\n  return Object.assign(\n    (\n      opt_: TarOptionsWithAliases | string[] = [],\n      entries?: string[] | CB,\n      cb?: CB,\n    ) => {\n      if (Array.isArray(opt_)) {\n        entries = opt_\n        opt_ = {}\n      }\n\n      if (typeof entries === 'function') {\n        cb = entries\n        entries = undefined\n      }\n\n      if (!entries) {\n        entries = []\n      } else {\n        entries = Array.from(entries)\n      }\n\n      const opt = dealias(opt_)\n\n      validate?.(opt, entries)\n\n      if (isSyncFile(opt)) {\n        if (typeof cb === 'function') {\n          throw new TypeError(\n            'callback not supported for sync tar functions',\n          )\n        }\n        return syncFile(opt, entries)\n      } else if (isAsyncFile(opt)) {\n        const p = asyncFile(opt, entries)\n        // weirdness to make TS happy\n        const c = cb ? cb : undefined\n        return c ? p.then(() => c(), c) : p\n      } else if (isSyncNoFile(opt)) {\n        if (typeof cb === 'function') {\n          throw new TypeError(\n            'callback not supported for sync tar functions',\n          )\n        }\n        return syncNoFile(opt, entries)\n      } else if (isAsyncNoFile(opt)) {\n        if (typeof cb === 'function') {\n          throw new TypeError(\n            'callback only supported with file option',\n          )\n        }\n        return asyncNoFile(opt, entries)\n        /* c8 ignore start */\n      } else {\n        throw new Error('impossible options??')\n      }\n      /* c8 ignore stop */\n    },\n    {\n      syncFile,\n      asyncFile,\n      syncNoFile,\n      asyncNoFile,\n      validate,\n    },\n  ) as TarCommand<AsyncClass, SyncClass>\n}\n","// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a list of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nimport { EventEmitter as EE } from 'events'\nimport { BrotliDecompress, Unzip, ZstdDecompress } from 'minizlib'\nimport { Header } from './header.js'\nimport { TarOptions } from './options.js'\nimport { Pax } from './pax.js'\nimport { ReadEntry } from './read-entry.js'\nimport {\n  warnMethod,\n  type WarnData,\n  type Warner,\n} from './warn-method.js'\n\nconst maxMetaEntrySize = 1024 * 1024\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst zstdHeader = Buffer.from([0x28, 0xb5, 0x2f, 0xfd])\nconst ZIP_HEADER_LEN = Math.max(gzipHeader.length, zstdHeader.length)\n\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = () => true\n\nexport type State = 'begin' | 'header' | 'ignore' | 'meta' | 'body'\n\nexport class Parser extends EE implements Warner {\n  file: string\n  strict: boolean\n  maxMetaEntrySize: number\n  filter: Exclude<TarOptions['filter'], undefined>\n  brotli?: TarOptions['brotli']\n  zstd?: TarOptions['zstd']\n\n  writable: true = true\n  readable: false = false;\n\n  [QUEUE]: (ReadEntry | [string | symbol, any, any])[] = [];\n  [BUFFER]?: Buffer;\n  [READENTRY]?: ReadEntry;\n  [WRITEENTRY]?: ReadEntry;\n  [STATE]: State = 'begin';\n  [META]: string = '';\n  [EX]?: Pax;\n  [GEX]?: Pax;\n  [ENDED]: boolean = false;\n  [UNZIP]?: false | Unzip | BrotliDecompress | ZstdDecompress;\n  [ABORTED]: boolean = false;\n  [SAW_VALID_ENTRY]?: boolean;\n  [SAW_NULL_BLOCK]: boolean = false;\n  [SAW_EOF]: boolean = false;\n  [WRITING]: boolean = false;\n  [CONSUMING]: boolean = false;\n  [EMITTEDEND]: boolean = false\n\n  constructor(opt: TarOptions = {}) {\n    super()\n\n    this.file = opt.file || ''\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, () => {\n      if (\n        this[STATE] === 'begin' ||\n        this[SAW_VALID_ENTRY] === false\n      ) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, () => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR =\n      opt.file &&\n      (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli =\n      !(opt.gzip || opt.zstd) && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // zstd has magic bytes to identify it, but we also support explicit options\n    // and file extension detection\n    const isTZST =\n      opt.file &&\n      (opt.file.endsWith('.tar.zst') || opt.file.endsWith('.tzst'))\n    this.zstd =\n      !(opt.gzip || opt.brotli) && opt.zstd !== undefined ? opt.zstd\n      : isTZST ? true\n      : undefined\n\n    // have to set this so that streams are ok piping into it\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onReadEntry === 'function') {\n      this.on('entry', opt.onReadEntry)\n    }\n  }\n\n  warn(\n    code: string,\n    message: string | Error,\n    data: WarnData = {},\n  ): void {\n    warnMethod(this, code, message, data)\n  }\n\n  [CONSUMEHEADER](chunk: Buffer, position: number) {\n    if (this[SAW_VALID_ENTRY] === undefined) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er as Error)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n            header,\n          })\n        } else if (\n          !/^(Symbolic)?Link$/.test(type) &&\n          !/^(Global)?ExtendedHeader$/.test(type) &&\n          header.linkpath\n        ) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n            header,\n          })\n        } else {\n          const entry = (this[WRITEENTRY] = new ReadEntry(\n            header,\n            this[EX],\n            this[GEX],\n          ))\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => (this[META] += c))\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = undefined\n            entry.ignore =\n              entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM]() {\n    queueMicrotask(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY](entry?: ReadEntry | [string | symbol, any, any]) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = undefined\n      go = false\n    } else if (Array.isArray(entry)) {\n      const [ev, ...args]: [string | symbol, any, any] = entry\n      this.emit(ev, ...args)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', () => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY]() {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', () => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY](chunk: Buffer, position: number) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    /* c8 ignore start */\n    if (!entry) {\n      throw new Error('attempt to consume body without entry??')\n    }\n    const br = entry.blockRemain ?? 0\n    /* c8 ignore stop */\n    const c =\n      br >= chunk.length && position === 0 ?\n        chunk\n      : chunk.subarray(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = undefined\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA](chunk: Buffer, position: number) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY] && entry) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT](ev: string | symbol, data?: any, extra?: any) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA](entry: ReadEntry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath': {\n        const ex = this[EX] ?? Object.create(null)\n        this[EX] = ex\n        ex.path = this[META].replace(/\\0.*/, '')\n        break\n      }\n\n      case 'NextFileHasLongLinkpath': {\n        const ex = this[EX] || Object.create(null)\n        this[EX] = ex\n        ex.linkpath = this[META].replace(/\\0.*/, '')\n        break\n      }\n\n      /* c8 ignore start */\n      default:\n        throw new Error('unknown meta: ' + entry.type)\n      /* c8 ignore stop */\n    }\n  }\n\n  abort(error: Error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write(\n    buffer: Uint8Array | string,\n    cb?: (err?: Error | null) => void,\n  ): boolean\n  write(\n    str: string,\n    encoding?: BufferEncoding,\n    cb?: (err?: Error | null) => void,\n  ): boolean\n  write(\n    chunk: Buffer | string,\n    encoding?: BufferEncoding | (() => any),\n    cb?: () => any,\n  ): boolean {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(\n        chunk,\n        /* c8 ignore next */\n        typeof encoding === 'string' ? encoding : 'utf8',\n      )\n    }\n    if (this[ABORTED]) {\n      /* c8 ignore next */\n      cb?.()\n      return false\n    }\n\n    // first write, might be gzipped, zstd, or brotli compressed\n    const needSniff =\n      this[UNZIP] === undefined ||\n      (this.brotli === undefined && this[UNZIP] === false)\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = undefined\n      }\n      if (chunk.length < ZIP_HEADER_LEN) {\n        this[BUFFER] = chunk\n        /* c8 ignore next */\n        cb?.()\n        return true\n      }\n\n      // look for gzip header\n      for (\n        let i = 0;\n        this[UNZIP] === undefined && i < gzipHeader.length;\n        i++\n      ) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      // look for zstd header if gzip header not found\n      let isZstd = false\n      if (this[UNZIP] === false && this.zstd !== false) {\n        isZstd = true\n        for (let i = 0; i < zstdHeader.length; i++) {\n          if (chunk[i] !== zstdHeader[i]) {\n            isZstd = false\n            break\n          }\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined && !isZstd\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            /* c8 ignore next */\n            cb?.()\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.subarray(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (\n        this[UNZIP] === undefined ||\n        (this[UNZIP] === false && (this.brotli || isZstd))\n      ) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] =\n          this[UNZIP] === undefined ? new Unzip({})\n          : isZstd ? new ZstdDecompress({})\n          : new BrotliDecompress({})\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er as Error))\n        this[UNZIP].on('end', () => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        cb?.()\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false\n      : this[READENTRY] ? this[READENTRY].flowing\n      : true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY]?.once('drain', () => this.emit('drain'))\n    }\n\n    /* c8 ignore next */\n    cb?.()\n    return ret\n  }\n\n  [BUFFERCONCAT](c: Buffer) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] =\n        this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND]() {\n    if (\n      this[ENDED] &&\n      !this[EMITTEDEND] &&\n      !this[ABORTED] &&\n      !this[CONSUMING]\n    ) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn(\n          'TAR_BAD_ARCHIVE',\n          `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`,\n          { entry },\n        )\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK](chunk?: Buffer) {\n    if (this[CONSUMING] && chunk) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else if (chunk) {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = undefined\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (\n        this[BUFFER] &&\n        (this[BUFFER] as Buffer)?.length >= 512 &&\n        !this[ABORTED] &&\n        !this[SAW_EOF]\n      ) {\n        const c = this[BUFFER]\n        this[BUFFER] = undefined\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB](chunk: Buffer) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (\n      position + 512 <= length &&\n      !this[ABORTED] &&\n      !this[SAW_EOF]\n    ) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* c8 ignore start */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n        /* c8 ignore stop */\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([\n          chunk.subarray(position),\n          this[BUFFER],\n        ])\n      } else {\n        this[BUFFER] = chunk.subarray(position)\n      }\n    }\n  }\n\n  end(cb?: () => void): this\n  end(data: string | Buffer, cb?: () => void): this\n  end(str: string, encoding?: BufferEncoding, cb?: () => void): this\n  end(\n    chunk?: string | Buffer | (() => void),\n    encoding?: BufferEncoding | (() => void),\n    cb?: () => void,\n  ) {\n    if (typeof chunk === 'function') {\n      cb = chunk\n      encoding = undefined\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding)\n    }\n    if (cb) this.once('finish', cb)\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        /* c8 ignore start */\n        if (chunk) this[UNZIP].write(chunk)\n        /* c8 ignore stop */\n        this[UNZIP].end()\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined || this.zstd === undefined)\n          chunk = chunk || Buffer.alloc(0)\n        if (chunk) this.write(chunk)\n        this[MAYBEEND]()\n      }\n    }\n    return this\n  }\n}\n","import assert from 'assert'\nimport { Buffer } from 'buffer'\nimport { Minipass } from 'minipass'\nimport * as realZlib from 'zlib'\nimport { constants } from './constants.js'\nexport { constants } from './constants.js'\n\nconst OriginalBufferConcat = Buffer.concat\nconst desc = Object.getOwnPropertyDescriptor(Buffer, 'concat')\nconst noop = (args: Buffer[]) => args as unknown as Buffer\nconst passthroughBufferConcat =\n  desc?.writable === true || desc?.set !== undefined\n    ? (makeNoOp: boolean) => {\n        Buffer.concat = makeNoOp ? noop : OriginalBufferConcat\n      }\n    : (_: boolean) => {}\n\nconst _superWrite = Symbol('_superWrite')\n\nexport class ZlibError extends Error {\n  code?: string\n  errno?: number\n  constructor(err: NodeJS.ErrnoException | Error, origin?: Function) {\n    super('zlib: ' + err.message, { cause: err })\n    this.code = (err as NodeJS.ErrnoException).code\n    this.errno = (err as NodeJS.ErrnoException).errno\n    /* c8 ignore next */\n    if (!this.code) this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, origin ?? this.constructor)\n  }\n\n  get name() {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _flushFlag = Symbol('flushFlag')\n\nexport type ChunkWithFlushFlag = Minipass.ContiguousData & {\n  [_flushFlag]?: number\n}\n\nexport type ZlibBaseOptions = Minipass.Options<Minipass.ContiguousData> & {\n  flush?: number\n  finishFlush?: number\n  fullFlushFlag?: number\n}\n\nexport type ZlibHandle =\n  | realZlib.Gzip\n  | realZlib.Gunzip\n  | realZlib.Deflate\n  | realZlib.Inflate\n  | realZlib.DeflateRaw\n  | realZlib.InflateRaw\n  | realZlib.BrotliCompress\n  | realZlib.BrotliDecompress\n  | realZlib.ZstdCompress\n  | realZlib.ZstdDecompress\nexport type ZlibMode =\n  | 'Gzip'\n  | 'Gunzip'\n  | 'Deflate'\n  | 'Inflate'\n  | 'DeflateRaw'\n  | 'InflateRaw'\n  | 'Unzip'\nexport type BrotliMode = 'BrotliCompress' | 'BrotliDecompress'\nexport type ZstdMode = 'ZstdCompress' | 'ZstdDecompress'\n\nabstract class ZlibBase extends Minipass<Buffer, ChunkWithFlushFlag> {\n  #sawError: boolean = false\n  #ended: boolean = false\n  #flushFlag: number\n  #finishFlushFlag: number\n  #fullFlushFlag: number\n  #handle?: ZlibHandle\n  #onError: (err: ZlibError) => any\n\n  get sawError() {\n    return this.#sawError\n  }\n  get handle() {\n    return this.#handle\n  }\n  /* c8 ignore start */\n  get flushFlag() {\n    return this.#flushFlag\n  }\n  /* c8 ignore stop */\n\n  constructor(opts: ZlibBaseOptions, mode: ZlibMode | BrotliMode | ZstdMode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    //@ts-ignore\n    super(opts)\n\n    /* c8 ignore start */\n    this.#flushFlag = opts.flush ?? 0\n    this.#finishFlushFlag = opts.finishFlush ?? 0\n    this.#fullFlushFlag = opts.fullFlushFlag ?? 0\n    /* c8 ignore stop */\n\n    //@ts-ignore\n    if (typeof realZlib[mode] !== 'function') {\n      throw new TypeError('Compression method not supported: ' + mode)\n    }\n\n    // this will throw if any options are invalid for the class selected\n    try {\n      // @types/node doesn't know that it exports the classes, but they're there\n      //@ts-ignore\n      this.#handle = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er as NodeJS.ErrnoException, this.constructor)\n    }\n\n    this.#onError = err => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this.#sawError) return\n\n      this.#sawError = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this.#handle?.on('error', er => this.#onError(new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close() {\n    if (this.#handle) {\n      this.#handle.close()\n      this.#handle = undefined\n      this.emit('close')\n    }\n  }\n\n  reset() {\n    if (!this.#sawError) {\n      assert(this.#handle, 'zlib binding closed')\n      //@ts-ignore\n      return this.#handle.reset?.()\n    }\n  }\n\n  flush(flushFlag?: number) {\n    if (this.ended) return\n\n    if (typeof flushFlag !== 'number') flushFlag = this.#fullFlushFlag\n\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end(cb?: () => void): this\n  end(chunk: ChunkWithFlushFlag, cb?: () => void): this\n  end(\n    chunk: ChunkWithFlushFlag,\n    encoding?: Minipass.Encoding,\n    cb?: () => void,\n  ): this\n  end(\n    chunk?: ChunkWithFlushFlag | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void,\n  ) {\n    /* c8 ignore start */\n    if (typeof chunk === 'function') {\n      cb = chunk\n      encoding = undefined\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    /* c8 ignore stop */\n    if (chunk) {\n      if (encoding) this.write(chunk, encoding)\n      else this.write(chunk)\n    }\n    this.flush(this.#finishFlushFlag)\n    this.#ended = true\n    return super.end(cb)\n  }\n\n  get ended() {\n    return this.#ended\n  }\n\n  // overridden in the gzip classes to do portable writes\n  [_superWrite](data: Buffer & { [_flushFlag]?: number }) {\n    return super.write(data)\n  }\n\n  write(chunk: ChunkWithFlushFlag, cb?: () => void): boolean\n  write(\n    chunk: ChunkWithFlushFlag,\n    encoding?: Minipass.Encoding,\n    cb?: () => void,\n  ): boolean\n  write(\n    chunk: ChunkWithFlushFlag,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void,\n  ) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      (cb = encoding), (encoding = 'utf8')\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk as string, encoding as BufferEncoding)\n\n    if (this.#sawError) return\n    assert(this.#handle, 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    // diving into the node:zlib internals a bit here\n    const nativeHandle = (this.#handle as unknown as { _handle: any })\n      ._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this.#handle.close\n    this.#handle.close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    passthroughBufferConcat(true)\n    let result: undefined | Buffer | Buffer[] = undefined\n    try {\n      const flushFlag =\n        typeof chunk[_flushFlag] === 'number'\n          ? chunk[_flushFlag]\n          : this.#flushFlag\n      result = (\n        this.#handle as unknown as {\n          _processChunk: (chunk: Buffer, flushFlag: number) => Buffer[]\n        }\n      )._processChunk(chunk as Buffer, flushFlag)\n      // if we don't throw, reset it back how it was\n      passthroughBufferConcat(false)\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      passthroughBufferConcat(false)\n      this.#onError(new ZlibError(err as NodeJS.ErrnoException, this.write))\n    } finally {\n      if (this.#handle) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        ;(this.#handle as unknown as { _handle: any })._handle =\n          nativeHandle\n        nativeHandle.close = originalNativeClose\n        this.#handle.close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this.#handle.removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this.#handle)\n      this.#handle.on('error', er => this.#onError(new ZlibError(er, this.write)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        const r = result[0]\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(r as Buffer))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i] as Buffer)\n        }\n      } else {\n        // either a single Buffer or an empty array\n        writeReturn = this[_superWrite](Buffer.from(result as Buffer | []))\n      }\n    }\n\n    if (cb) cb()\n    return writeReturn\n  }\n}\n\nexport type ZlibOptions = ZlibBaseOptions & {\n  level?: number\n  strategy?: number\n}\n\nexport class Zlib extends ZlibBase {\n  #level?: number\n  #strategy?: number\n\n  constructor(opts: ZlibOptions, mode: ZlibMode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    opts.fullFlushFlag = constants.Z_FULL_FLUSH\n    super(opts, mode)\n\n    this.#level = opts.level\n    this.#strategy = opts.strategy\n  }\n\n  params(level: number, strategy: number) {\n    if (this.sawError) return\n\n    if (!this.handle)\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* c8 ignore start */\n    if (!(this.handle as { params?: any }).params)\n      throw new Error('not supported in this implementation')\n    /* c8 ignore stop */\n\n    if (this.#level !== level || this.#strategy !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this.handle, 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this.handle.flush\n      this.handle.flush = (\n        flushFlag?: (() => void) | number,\n        cb?: () => void,\n      ) => {\n        /* c8 ignore start */\n        if (typeof flushFlag === 'function') {\n          cb = flushFlag\n          flushFlag = this.flushFlag\n        }\n        /* c8 ignore stop */\n        this.flush(flushFlag)\n        cb?.()\n      }\n      try {\n        ;(\n          this.handle as unknown as {\n            params: (level?: number, strategy?: number) => void\n          }\n        ).params(level, strategy)\n      } finally {\n        this.handle.flush = origFlush\n      }\n      /* c8 ignore start */\n      if (this.handle) {\n        this.#level = level\n        this.#strategy = strategy\n      }\n      /* c8 ignore stop */\n    }\n  }\n}\n\n// minimal 2-byte header\nexport class Deflate extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'Deflate')\n  }\n}\n\nexport class Inflate extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nexport type GzipOptions = ZlibOptions & { portable?: boolean }\nexport class Gzip extends Zlib {\n  #portable: boolean\n  constructor(opts: GzipOptions) {\n    super(opts, 'Gzip')\n    this.#portable = opts && !!opts.portable\n  }\n\n  [_superWrite](data: Buffer & { [_flushFlag]?: number }) {\n    if (!this.#portable) return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this.#portable = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nexport class Gunzip extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nexport class DeflateRaw extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nexport class InflateRaw extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nexport class Unzip extends Zlib {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor(opts: ZlibOptions, mode: BrotliMode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush =\n      opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n    opts.fullFlushFlag = constants.BROTLI_OPERATION_FLUSH\n    super(opts, mode)\n  }\n}\n\nexport class BrotliCompress extends Brotli {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nexport class BrotliDecompress extends Brotli {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nclass Zstd extends ZlibBase {\n  constructor(opts: ZlibOptions, mode: ZstdMode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.ZSTD_e_continue\n    opts.finishFlush = opts.finishFlush || constants.ZSTD_e_end\n    opts.fullFlushFlag = constants.ZSTD_e_flush\n    super(opts, mode)\n  }\n}\n\nexport class ZstdCompress extends Zstd {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'ZstdCompress')\n  }\n}\n\nexport class ZstdDecompress extends Zstd {\n  constructor(opts: ZlibOptions) {\n    super(opts, 'ZstdDecompress')\n  }\n}\n","// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nimport realZlib from 'zlib'\n/* c8 ignore start */\nconst realZlibConstants = realZlib.constants || { ZLIB_VERNUM: 4736 }\n/* c8 ignore stop */\n\nexport const constants = Object.freeze(\n  Object.assign(\n    Object.create(null),\n    {\n      Z_NO_FLUSH: 0,\n      Z_PARTIAL_FLUSH: 1,\n      Z_SYNC_FLUSH: 2,\n      Z_FULL_FLUSH: 3,\n      Z_FINISH: 4,\n      Z_BLOCK: 5,\n      Z_OK: 0,\n      Z_STREAM_END: 1,\n      Z_NEED_DICT: 2,\n      Z_ERRNO: -1,\n      Z_STREAM_ERROR: -2,\n      Z_DATA_ERROR: -3,\n      Z_MEM_ERROR: -4,\n      Z_BUF_ERROR: -5,\n      Z_VERSION_ERROR: -6,\n      Z_NO_COMPRESSION: 0,\n      Z_BEST_SPEED: 1,\n      Z_BEST_COMPRESSION: 9,\n      Z_DEFAULT_COMPRESSION: -1,\n      Z_FILTERED: 1,\n      Z_HUFFMAN_ONLY: 2,\n      Z_RLE: 3,\n      Z_FIXED: 4,\n      Z_DEFAULT_STRATEGY: 0,\n      DEFLATE: 1,\n      INFLATE: 2,\n      GZIP: 3,\n      GUNZIP: 4,\n      DEFLATERAW: 5,\n      INFLATERAW: 6,\n      UNZIP: 7,\n      BROTLI_DECODE: 8,\n      BROTLI_ENCODE: 9,\n      Z_MIN_WINDOWBITS: 8,\n      Z_MAX_WINDOWBITS: 15,\n      Z_DEFAULT_WINDOWBITS: 15,\n      Z_MIN_CHUNK: 64,\n      Z_MAX_CHUNK: Infinity,\n      Z_DEFAULT_CHUNK: 16384,\n      Z_MIN_MEMLEVEL: 1,\n      Z_MAX_MEMLEVEL: 9,\n      Z_DEFAULT_MEMLEVEL: 8,\n      Z_MIN_LEVEL: -1,\n      Z_MAX_LEVEL: 9,\n      Z_DEFAULT_LEVEL: -1,\n      BROTLI_OPERATION_PROCESS: 0,\n      BROTLI_OPERATION_FLUSH: 1,\n      BROTLI_OPERATION_FINISH: 2,\n      BROTLI_OPERATION_EMIT_METADATA: 3,\n      BROTLI_MODE_GENERIC: 0,\n      BROTLI_MODE_TEXT: 1,\n      BROTLI_MODE_FONT: 2,\n      BROTLI_DEFAULT_MODE: 0,\n      BROTLI_MIN_QUALITY: 0,\n      BROTLI_MAX_QUALITY: 11,\n      BROTLI_DEFAULT_QUALITY: 11,\n      BROTLI_MIN_WINDOW_BITS: 10,\n      BROTLI_MAX_WINDOW_BITS: 24,\n      BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n      BROTLI_DEFAULT_WINDOW: 22,\n      BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n      BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n      BROTLI_PARAM_MODE: 0,\n      BROTLI_PARAM_QUALITY: 1,\n      BROTLI_PARAM_LGWIN: 2,\n      BROTLI_PARAM_LGBLOCK: 3,\n      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n      BROTLI_PARAM_SIZE_HINT: 5,\n      BROTLI_PARAM_LARGE_WINDOW: 6,\n      BROTLI_PARAM_NPOSTFIX: 7,\n      BROTLI_PARAM_NDIRECT: 8,\n      BROTLI_DECODER_RESULT_ERROR: 0,\n      BROTLI_DECODER_RESULT_SUCCESS: 1,\n      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n      BROTLI_DECODER_NO_ERROR: 0,\n      BROTLI_DECODER_SUCCESS: 1,\n      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n      BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n    },\n    realZlibConstants,\n  ),\n)\n","// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nimport { posix as pathModule } from 'node:path'\nimport * as large from './large-numbers.js'\nimport type { EntryTypeCode, EntryTypeName } from './types.js'\nimport * as types from './types.js'\n\nexport type HeaderData = {\n  path?: string\n  mode?: number\n  uid?: number\n  gid?: number\n  size?: number\n  cksum?: number\n  type?: EntryTypeName | 'Unsupported'\n  linkpath?: string\n  uname?: string\n  gname?: string\n  devmaj?: number\n  devmin?: number\n  atime?: Date\n  ctime?: Date\n  mtime?: Date\n\n  // fields that are common in extended PAX headers, but not in the\n  // \"standard\" tar header block\n  charset?: string\n  comment?: string\n  dev?: number\n  ino?: number\n  nlink?: number\n}\n\nexport class Header implements HeaderData {\n  cksumValid: boolean = false\n  needPax: boolean = false\n  nullBlock: boolean = false\n\n  block?: Buffer\n  path?: string\n  mode?: number\n  uid?: number\n  gid?: number\n  size?: number\n  cksum?: number\n  #type: EntryTypeCode | 'Unsupported' = 'Unsupported'\n  linkpath?: string\n  uname?: string\n  gname?: string\n  devmaj: number = 0\n  devmin: number = 0\n  atime?: Date\n  ctime?: Date\n  mtime?: Date\n\n  charset?: string\n  comment?: string\n\n  constructor(\n    data?: Buffer | HeaderData,\n    off: number = 0,\n    ex?: HeaderData,\n    gex?: HeaderData,\n  ) {\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.#slurp(data)\n    }\n  }\n\n  decode(\n    buf: Buffer,\n    off: number,\n    ex?: HeaderData,\n    gex?: HeaderData,\n  ) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = ex?.path ?? decString(buf, off, 100)\n    this.mode = ex?.mode ?? gex?.mode ?? decNumber(buf, off + 100, 8)\n    this.uid = ex?.uid ?? gex?.uid ?? decNumber(buf, off + 108, 8)\n    this.gid = ex?.gid ?? gex?.gid ?? decNumber(buf, off + 116, 8)\n    this.size = ex?.size ?? gex?.size ?? decNumber(buf, off + 124, 12)\n    this.mtime =\n      ex?.mtime ?? gex?.mtime ?? decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    // Apply global before local, so it overrides\n    if (gex) this.#slurp(gex, true)\n    if (ex) this.#slurp(ex)\n\n    // old tar versions marked dirs as a file with a trailing /\n    const t = decString(buf, off + 156, 1)\n    if (types.isCode(t)) {\n      this.#type = t || '0'\n    }\n    if (this.#type === '0' && this.path.slice(-1) === '/') {\n      this.#type = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this.#type === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (\n      buf.subarray(off + 257, off + 265).toString() ===\n      'ustar\\u000000'\n    ) {\n      /* c8 ignore start */\n      this.uname =\n        ex?.uname ?? gex?.uname ?? decString(buf, off + 265, 32)\n      this.gname =\n        ex?.gname ?? gex?.gname ?? decString(buf, off + 297, 32)\n      this.devmaj =\n        ex?.devmaj ?? gex?.devmaj ?? decNumber(buf, off + 329, 8) ?? 0\n      this.devmin =\n        ex?.devmin ?? gex?.devmin ?? decNumber(buf, off + 337, 8) ?? 0\n      /* c8 ignore stop */\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        /* c8 ignore start */\n        this.atime =\n          ex?.atime ?? gex?.atime ?? decDate(buf, off + 476, 12)\n        this.ctime =\n          ex?.ctime ?? gex?.ctime ?? decDate(buf, off + 488, 12)\n        /* c8 ignore stop */\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i] as number\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i] as number\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === undefined && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  #slurp(ex: HeaderData, gex: boolean = false) {\n    Object.assign(\n      this,\n      Object.fromEntries(\n        Object.entries(ex).filter(([k, v]) => {\n          // we slurp in everything except for the path attribute in\n          // a global extended header, because that's weird. Also, any\n          // null/undefined values are ignored.\n          return !(\n            v === null ||\n            v === undefined ||\n            (k === 'path' && gex) ||\n            (k === 'linkpath' && gex) ||\n            k === 'global'\n          )\n        }),\n      ),\n    )\n  }\n\n  encode(buf?: Buffer, off: number = 0) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n    }\n\n    if (this.#type === 'Unsupported') {\n      this.#type = '0'\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = !!split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax =\n      encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this.#type.charCodeAt(0)\n    this.needPax =\n      encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax =\n      encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax =\n      encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax =\n      encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax =\n      encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax =\n        encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax =\n        encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax =\n        encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax =\n        encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i] as number\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i] as number\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  get type(): EntryTypeName {\n    return (\n      this.#type === 'Unsupported' ?\n        this.#type\n      : types.name.get(this.#type)) as EntryTypeName\n  }\n\n  get typeKey(): EntryTypeCode | 'Unsupported' {\n    return this.#type\n  }\n\n  set type(type: EntryTypeCode | EntryTypeName | 'Unsupported') {\n    const c = String(types.code.get(type as EntryTypeName))\n    if (types.isCode(c) || c === 'Unsupported') {\n      this.#type = c\n    } else if (types.isCode(type)) {\n      this.#type = type\n    } else {\n      throw new TypeError('invalid entry type: ' + type)\n    }\n  }\n}\n\nconst splitPrefix = (\n  p: string,\n  prefixSize: number,\n): [string, string, boolean] => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret: undefined | [string, string, boolean] = undefined\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (\n        Buffer.byteLength(pp) <= pathSize &&\n        Buffer.byteLength(prefix) <= prefixSize\n      ) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (\n        Buffer.byteLength(pp) > pathSize &&\n        Buffer.byteLength(prefix) <= prefixSize\n      ) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && ret === undefined)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf: Buffer, off: number, size: number) =>\n  buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*/, '')\n\nconst decDate = (buf: Buffer, off: number, size: number) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = (num?: number) =>\n  num === undefined ? undefined : new Date(num * 1000)\n\nconst decNumber = (buf: Buffer, off: number, size: number) =>\n  Number(buf[off]) & 0x80 ?\n    large.parse(buf.subarray(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanUndef = (value: number) => (isNaN(value) ? undefined : value)\n\nconst decSmallNumber = (buf: Buffer, off: number, size: number) =>\n  nanUndef(\n    parseInt(\n      buf\n        .subarray(off, off + size)\n        .toString('utf8')\n        .replace(/\\0.*$/, '')\n        .trim(),\n      8,\n    ),\n  )\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (\n  buf: Buffer,\n  off: number,\n  size: 12 | 8,\n  num?: number,\n) =>\n  num === undefined ? false\n  : num > MAXNUM[size] || num < 0 ?\n    (large.encode(num, buf.subarray(off, off + size)), true)\n  : (encSmallNumber(buf, off, size, num), false)\n\nconst encSmallNumber = (\n  buf: Buffer,\n  off: number,\n  size: number,\n  num: number,\n) => buf.write(octalString(num, size), off, size, 'ascii')\n\nconst octalString = (num: number, size: number) =>\n  padOctal(Math.floor(num).toString(8), size)\n\nconst padOctal = (str: string, size: number) =>\n  (str.length === size - 1 ?\n    str\n  : new Array(size - str.length - 1).join('0') + str + ' ') + '\\0'\n\nconst encDate = (\n  buf: Buffer,\n  off: number,\n  size: 8 | 12,\n  date?: Date,\n) =>\n  date === undefined ? false : (\n    encNumber(buf, off, size, date.getTime() / 1000)\n  )\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (\n  buf: Buffer,\n  off: number,\n  size: number,\n  str?: string,\n) =>\n  str === undefined ? false : (\n    (buf.write(str + NULLS, off, size, 'utf8'),\n    str.length !== Buffer.byteLength(str) || str.length > size)\n  )\n","// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nexport const encode = (num: number, buf: Buffer) => {\n  if (!Number.isSafeInteger(num)) {\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error(\n      'cannot encode number outside of javascript safe integer range',\n    )\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num: number, buf: Buffer) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num: number, buf: Buffer) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nexport const parse = (buf: Buffer) => {\n  const pre = buf[0]\n  const value =\n    pre === 0x80 ? pos(buf.subarray(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n    // The number is so large that javascript cannot represent it with integer\n    // precision.\n    throw Error(\n      'parsed number outside of javascript safe integer range',\n    )\n  }\n\n  return value\n}\n\nconst twos = (buf: Buffer) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = Number(buf[i])\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf: Buffer) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = Number(buf[i])\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = (byte: number) => (0xff ^ byte) & 0xff\n\nconst twosComp = (byte: number) => ((0xff ^ byte) + 1) & 0xff\n","export const isCode = (c: string): c is EntryTypeCode =>\n  name.has(c as EntryTypeCode)\n\nexport const isName = (c: string): c is EntryTypeName =>\n  code.has(c as EntryTypeName)\n\nexport type EntryTypeCode =\n  | '0'\n  | ''\n  | '1'\n  | '2'\n  | '3'\n  | '4'\n  | '5'\n  | '6'\n  | '7'\n  | 'g'\n  | 'x'\n  | 'A'\n  | 'D'\n  | 'I'\n  | 'K'\n  | 'L'\n  | 'M'\n  | 'N'\n  | 'S'\n  | 'V'\n  | 'X'\n\nexport type EntryTypeName =\n  | 'File'\n  | 'OldFile'\n  | 'Link'\n  | 'SymbolicLink'\n  | 'CharacterDevice'\n  | 'BlockDevice'\n  | 'Directory'\n  | 'FIFO'\n  | 'ContiguousFile'\n  | 'GlobalExtendedHeader'\n  | 'ExtendedHeader'\n  | 'SolarisACL'\n  | 'GNUDumpDir'\n  | 'Inode'\n  | 'NextFileHasLongLinkpath'\n  | 'NextFileHasLongPath'\n  | 'ContinuationFile'\n  | 'OldGnuLongPath'\n  | 'SparseFile'\n  | 'TapeVolumeHeader'\n  | 'OldExtendedHeader'\n  | 'Unsupported'\n\n// map types from key to human-friendly name\nexport const name = new Map<EntryTypeCode, EntryTypeName>([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexport const code = new Map<EntryTypeName, EntryTypeCode>(\n  Array.from(name).map(kv => [kv[1], kv[0]]),\n)\n","import { basename } from 'node:path'\nimport { Header, HeaderData } from './header.js'\n\nexport class Pax implements HeaderData {\n  atime?: Date\n  mtime?: Date\n  ctime?: Date\n\n  charset?: string\n  comment?: string\n\n  gid?: number\n  uid?: number\n\n  gname?: string\n  uname?: string\n  linkpath?: string\n  dev?: number\n  ino?: number\n  nlink?: number\n  path?: string\n  size?: number\n  mode?: number\n\n  global: boolean\n\n  constructor(obj: HeaderData, global: boolean = false) {\n    this.atime = obj.atime\n    this.charset = obj.charset\n    this.comment = obj.comment\n    this.ctime = obj.ctime\n    this.dev = obj.dev\n    this.gid = obj.gid\n    this.global = global\n    this.gname = obj.gname\n    this.ino = obj.ino\n    this.linkpath = obj.linkpath\n    this.mtime = obj.mtime\n    this.nlink = obj.nlink\n    this.path = obj.path\n    this.size = obj.size\n    this.uid = obj.uid\n    this.uname = obj.uname\n  }\n\n  encode() {\n    const body = this.encodeBody()\n    if (body === '') {\n      return Buffer.allocUnsafe(0)\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      /* c8 ignore start */\n      path: ('PaxHeader/' + basename(this.path ?? '')).slice(0, 99),\n      /* c8 ignore stop */\n      mode: this.mode || 0o644,\n      uid: this.uid,\n      gid: this.gid,\n      size: bodyLen,\n      mtime: this.mtime,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime,\n      ctime: this.ctime,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody() {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField(field: keyof Pax): string {\n    if (this[field] === undefined) {\n      return ''\n    }\n    const r = this[field]\n    const v = r instanceof Date ? r.getTime() / 1000 : r\n    const s =\n      ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink' ?\n        'SCHILY.'\n      : '') +\n      field +\n      '=' +\n      v +\n      '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n\n  static parse(str: string, ex?: HeaderData, g: boolean = false) {\n    return new Pax(merge(parseKV(str), ex), g)\n  }\n}\n\nconst merge = (a: HeaderData, b?: HeaderData) =>\n  b ? Object.assign({}, b, a) : a\n\nconst parseKV = (str: string) =>\n  str\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set: Record<string, any>, line: string) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const r = kv.shift()\n\n  if (!r) {\n    return set\n  }\n\n  const k = r.replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n\n  const v = kv.join('=')\n  set[k] =\n    /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ?\n      new Date(Number(v) * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n","// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform =\n  process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\n\nexport const normalizeWindowsPath =\n  platform !== 'win32' ?\n    (p: string) => p\n  : (p: string) => p && p.replace(/\\\\/g, '/')\n","import { Minipass } from 'minipass'\nimport { Header } from './header.js'\nimport { normalizeWindowsPath } from './normalize-windows-path.js'\nimport { Pax } from './pax.js'\nimport { EntryTypeName } from './types.js'\n\nexport class ReadEntry extends Minipass<Buffer, Buffer> {\n  extended?: Pax\n  globalExtended?: Pax\n  header: Header\n  startBlockSize: number\n  blockRemain: number\n  remain: number\n  type: EntryTypeName\n  meta: boolean = false\n  ignore: boolean = false\n  path: string\n  mode?: number\n  uid?: number\n  gid?: number\n  uname?: string\n  gname?: string\n  size: number = 0\n  mtime?: Date\n  atime?: Date\n  ctime?: Date\n  linkpath?: string\n\n  dev?: number\n  ino?: number\n  nlink?: number\n  invalid: boolean = false\n  absolute?: string\n  unsupported: boolean = false\n\n  constructor(header: Header, ex?: Pax, gex?: Pax) {\n    super({})\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    /* c8 ignore start */\n    this.remain = header.size ?? 0\n    /* c8 ignore stop */\n    this.startBlockSize = 512 * Math.ceil(this.remain / 512)\n    this.blockRemain = this.startBlockSize\n    this.type = header.type\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    /* c8 ignore start */\n    if (!header.path) {\n      throw new Error('no path provided for tar.ReadEntry')\n    }\n    /* c8 ignore stop */\n\n    this.path = normalizeWindowsPath(header.path) as string\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = this.remain\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    /* c8 ignore start */\n    this.linkpath =\n      header.linkpath ?\n        normalizeWindowsPath(header.linkpath)\n      : undefined\n    /* c8 ignore stop */\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this.#slurp(ex)\n    }\n    if (gex) {\n      this.#slurp(gex, true)\n    }\n  }\n\n  write(data: Buffer) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.subarray(0, r))\n  }\n\n  #slurp(ex: Pax, gex: boolean = false) {\n    if (ex.path) ex.path = normalizeWindowsPath(ex.path)\n    if (ex.linkpath) ex.linkpath = normalizeWindowsPath(ex.linkpath)\n    Object.assign(\n      this,\n      Object.fromEntries(\n        Object.entries(ex).filter(([k, v]) => {\n          // we slurp in everything except for the path attribute in\n          // a global extended header, because that's weird. Also, any\n          // null/undefined values are ignored.\n          return !(\n            v === null ||\n            v === undefined ||\n            (k === 'path' && gex)\n          )\n        }),\n      ),\n    )\n  }\n}\n","import { type Minipass } from 'minipass'\n\n/** has a warn method */\nexport type Warner = {\n  warn(code: string, message: string | Error, data: any): void\n  file?: string\n  cwd?: string\n  strict?: boolean\n\n  emit(\n    event: 'warn',\n    code: string,\n    message: string,\n    data?: WarnData,\n  ): void\n  emit(event: 'error', error: TarError): void\n}\n\nexport type WarnEvent<T = Buffer> = Minipass.Events<T> & {\n  warn: [code: string, message: string, data: WarnData]\n}\n\nexport type WarnData = {\n  file?: string\n  cwd?: string\n  code?: string\n  tarCode?: string\n  recoverable?: boolean\n  [k: string]: any\n}\n\nexport type TarError = Error & WarnData\n\nexport const warnMethod = (\n  self: Warner,\n  code: string,\n  message: string | Error,\n  data: WarnData = {},\n) => {\n  if (self.file) {\n    data.file = self.file\n  }\n  if (self.cwd) {\n    data.cwd = self.cwd\n  }\n  data.code =\n    (message instanceof Error &&\n      (message as NodeJS.ErrnoException).code) ||\n    code\n  data.tarCode = code\n  if (!self.strict && data.recoverable !== false) {\n    if (message instanceof Error) {\n      data = Object.assign(message, data)\n      message = message.message\n    }\n    self.emit('warn', code, message, data)\n  } else if (message instanceof Error) {\n    self.emit('error', Object.assign(message, data))\n  } else {\n    self.emit(\n      'error',\n      Object.assign(new Error(`${code}: ${message}`), data),\n    )\n  }\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nexport const stripTrailingSlashes = (str: string) => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n","// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nimport fs, { type Stats } from 'fs'\nimport {\n  WriteEntry,\n  WriteEntrySync,\n  WriteEntryTar,\n} from './write-entry.js'\n\nexport class PackJob {\n  path: string\n  absolute: string\n  entry?: WriteEntry | WriteEntryTar\n  stat?: Stats\n  readdir?: string[]\n  pending: boolean = false\n  ignore: boolean = false\n  piped: boolean = false\n  constructor(path: string, absolute: string) {\n    this.path = path || './'\n    this.absolute = absolute\n  }\n}\n\nimport { Minipass } from 'minipass'\nimport * as zlib from 'minizlib'\nimport { Yallist } from 'yallist'\nimport { ReadEntry } from './read-entry.js'\nimport {\n  WarnEvent,\n  warnMethod,\n  type WarnData,\n  type Warner,\n} from './warn-method.js'\n\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nimport path from 'path'\nimport { normalizeWindowsPath } from './normalize-windows-path.js'\nimport { TarOptions } from './options.js'\n\nexport class Pack\n  extends Minipass<Buffer, ReadEntry | string, WarnEvent<Buffer>>\n  implements Warner\n{\n  sync: boolean = false\n  opt: TarOptions\n  cwd: string\n  maxReadSize?: number\n  preservePaths: boolean\n  strict: boolean\n  noPax: boolean\n  prefix: string\n  linkCache: Exclude<TarOptions['linkCache'], undefined>\n  statCache: Exclude<TarOptions['statCache'], undefined>\n  file: string\n  portable: boolean\n  zip?: zlib.BrotliCompress | zlib.Gzip | zlib.ZstdCompress\n  readdirCache: Exclude<TarOptions['readdirCache'], undefined>\n  noDirRecurse: boolean\n  follow: boolean\n  noMtime: boolean\n  mtime?: Date\n  filter: Exclude<TarOptions['filter'], undefined>\n  jobs: number;\n\n  [WRITEENTRYCLASS]: typeof WriteEntry | typeof WriteEntrySync\n  onWriteEntry?: (entry: WriteEntry) => void;\n  // Note: we actually DO need a linked list here, because we\n  // shift() to update the head of the list where we start, but still\n  // while that happens, need to know what the next item in the queue\n  // will be. Since we do multiple jobs in parallel, it's not as simple\n  // as just an Array.shift(), since that would lose the information about\n  // the next job in the list. We could add a .next field on the PackJob\n  // class, but then we'd have to be tracking the tail of the queue the\n  // whole time, and Yallist just does that for us anyway.\n  [QUEUE]: Yallist<PackJob>;\n  [JOBS]: number = 0;\n  [PROCESSING]: boolean = false;\n  [ENDED]: boolean = false\n\n  constructor(opt: TarOptions = {}) {\n    //@ts-ignore\n    super()\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normalizeWindowsPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n    this.onWriteEntry = opt.onWriteEntry\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n\n    if (opt.gzip || opt.brotli || opt.zstd) {\n      if (\n        (opt.gzip ? 1 : 0) +\n          (opt.brotli ? 1 : 0) +\n          (opt.zstd ? 1 : 0) >\n        1\n      ) {\n        throw new TypeError(\n          'gzip, brotli, zstd are mutually exclusive',\n        )\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      if (opt.zstd) {\n        if (typeof opt.zstd !== 'object') {\n          opt.zstd = {}\n        }\n        this.zip = new zlib.ZstdCompress(opt.zstd)\n      }\n      /* c8 ignore next */\n      if (!this.zip) throw new Error('impossible')\n      const zip = this.zip\n      zip.on('data', chunk => super.write(chunk as unknown as string))\n      zip.on('end', () => super.end())\n      zip.on('drain', () => this[ONDRAIN]())\n      this.on('resume', () => zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    if (opt.mtime) this.mtime = opt.mtime\n\n    this.filter =\n      typeof opt.filter === 'function' ? opt.filter : () => true\n\n    this[QUEUE] = new Yallist<PackJob>()\n    this[JOBS] = 0\n    this.jobs = Number(opt.jobs) || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE](chunk: Buffer) {\n    return super.write(chunk as unknown as string)\n  }\n\n  add(path: string | ReadEntry) {\n    this.write(path)\n    return this\n  }\n\n  end(cb?: () => void): this\n  end(path: string | ReadEntry, cb?: () => void): this\n  end(\n    path: string | ReadEntry,\n    encoding?: Minipass.Encoding,\n    cb?: () => void,\n  ): this\n  end(\n    path?: string | ReadEntry | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void,\n  ) {\n    /* c8 ignore start */\n    if (typeof path === 'function') {\n      cb = path\n      path = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    /* c8 ignore stop */\n    if (path) {\n      this.add(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    /* c8 ignore next */\n    if (cb) cb()\n    return this\n  }\n\n  write(path: string | ReadEntry) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY](p: ReadEntry) {\n    const absolute = normalizeWindowsPath(\n      path.resolve(this.cwd, p.path),\n    )\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', () => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY](p: string) {\n    const absolute = normalizeWindowsPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT](job: PackJob) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT](job: PackJob, stat: Stats) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    } else if (\n      stat.isFile() &&\n      stat.nlink > 1 &&\n      job === this[CURRENT] &&\n      !this.linkCache.get(`${stat.dev}:${stat.ino}`) &&\n      !this.sync\n    ) {\n      // if it's not filtered, and it's a new File entry,\n      // jump the queue in case any pending Link entries are about\n      // to try to link to it. This prevents a hardlink from coming ahead\n      // of its target in the archive.\n      this[PROCESSJOB](job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR](job: PackJob) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR](job: PackJob, entries: string[]) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS]() {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (\n      let w = this[QUEUE].head;\n      !!w && this[JOBS] < this.jobs;\n      w = w.next\n    ) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF as unknown as string)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT]() {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE](_job: PackJob) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB](job: PackJob) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      const sc = this.statCache.get(job.absolute)\n      if (sc) {\n        this[ONSTAT](job, sc)\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (\n      !this.noDirRecurse &&\n      job.stat.isDirectory() &&\n      !job.readdir\n    ) {\n      const rc = this.readdirCache.get(job.absolute)\n      if (rc) {\n        this[ONREADDIR](job, rc)\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT](job: PackJob): TarOptions {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n      onWriteEntry: this.onWriteEntry,\n    }\n  }\n\n  [ENTRY](job: PackJob) {\n    this[JOBS] += 1\n    try {\n      const e = new this[WRITEENTRYCLASS](\n        job.path,\n        this[ENTRYOPT](job),\n      )\n      return e\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN]() {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE](job: PackJob) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n    /* c8 ignore start */\n    if (!source) throw new Error('cannot pipe without source')\n    /* c8 ignore stop */\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk as unknown as string)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause() {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n  warn(\n    code: string,\n    message: string | Error,\n    data: WarnData = {},\n  ): void {\n    warnMethod(this, code, message, data)\n  }\n}\n\nexport class PackSync extends Pack {\n  sync: true = true\n  constructor(opt: TarOptions) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause() {}\n  resume() {}\n\n  [STAT](job: PackJob) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR](job: PackJob) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE](job: PackJob) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    /* c8 ignore start */\n    if (!source) throw new Error('Cannot pipe without source')\n    /* c8 ignore stop */\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n","import fs, { type Stats } from 'fs'\nimport { Minipass } from 'minipass'\nimport path from 'path'\nimport { Header } from './header.js'\nimport { modeFix } from './mode-fix.js'\nimport { normalizeWindowsPath } from './normalize-windows-path.js'\nimport {\n  dealias,\n  LinkCacheKey,\n  TarOptions,\n  TarOptionsWithAliases,\n} from './options.js'\nimport { Pax } from './pax.js'\nimport { ReadEntry } from './read-entry.js'\nimport { stripAbsolutePath } from './strip-absolute-path.js'\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js'\nimport { EntryTypeName } from './types.js'\nimport {\n  WarnData,\n  Warner,\n  WarnEvent,\n  warnMethod,\n} from './warn-method.js'\nimport * as winchars from './winchars.js'\n\nconst prefixPath = (path: string, prefix?: string) => {\n  if (!prefix) {\n    return normalizeWindowsPath(path)\n  }\n  path = normalizeWindowsPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripTrailingSlashes(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\n\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\n\nexport class WriteEntry\n  extends Minipass<Buffer, Minipass.ContiguousData, WarnEvent>\n  implements Warner\n{\n  path: string\n  portable: boolean\n  myuid: number = (process.getuid && process.getuid()) || 0\n  // until node has builtin pwnam functions, this'll have to do\n  myuser: string = process.env.USER || ''\n  maxReadSize: number\n  linkCache: Exclude<TarOptions['linkCache'], undefined>\n  statCache: Exclude<TarOptions['statCache'], undefined>\n  preservePaths: boolean\n  cwd: string\n  strict: boolean\n  mtime?: Date\n  noPax: boolean\n  noMtime: boolean\n  prefix?: string\n  fd?: number\n\n  blockLen: number = 0\n  blockRemain: number = 0\n  buf?: Buffer\n  pos: number = 0\n  remain: number = 0\n  length: number = 0\n  offset: number = 0\n\n  win32: boolean\n  absolute: string\n\n  header?: Header\n  type?: EntryTypeName | 'Unsupported'\n  linkpath?: string\n  stat?: Stats\n  onWriteEntry?: (entry: WriteEntry) => any\n\n  #hadError: boolean = false\n\n  constructor(p: string, opt_: TarOptionsWithAliases = {}) {\n    const opt = dealias(opt_)\n    super()\n    this.path = normalizeWindowsPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normalizeWindowsPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime\n    this.prefix =\n      opt.prefix ? normalizeWindowsPath(opt.prefix) : undefined\n    this.onWriteEntry = opt.onWriteEntry\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn: string | boolean = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root && typeof stripped === 'string') {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normalizeWindowsPath(\n      opt.absolute || path.resolve(this.cwd, p),\n    )\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn(\n        'TAR_ENTRY_INFO',\n        `stripping ${pathWarn} from absolute path`,\n        {\n          entry: this,\n          path: pathWarn + this.path,\n        },\n      )\n    }\n\n    const cs = this.statCache.get(this.absolute)\n    if (cs) {\n      this[ONLSTAT](cs)\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  warn(code: string, message: string | Error, data: WarnData = {}) {\n    return warnMethod(this, code, message, data)\n  }\n\n  emit(ev: keyof WarnEvent, ...data: any[]) {\n    if (ev === 'error') {\n      this.#hadError = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT]() {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT](stat: Stats) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS]() {\n    switch (this.type) {\n      case 'File':\n        return this[FILE]()\n      case 'Directory':\n        return this[DIRECTORY]()\n      case 'SymbolicLink':\n        return this[SYMLINK]()\n      // unsupported types are ignored.\n      default:\n        return this.end()\n    }\n  }\n\n  [MODE](mode: number) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX](path: string) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER]() {\n    /* c8 ignore start */\n    if (!this.stat) {\n      throw new Error('cannot write header before stat')\n    }\n    /* c8 ignore stop */\n\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.onWriteEntry?.(this)\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath:\n        this.type === 'Link' && this.linkpath !== undefined ?\n          this[PREFIX](this.linkpath)\n        : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? undefined : this.stat.uid,\n      gid: this.portable ? undefined : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,\n      /* c8 ignore next */\n      type: this.type === 'Unsupported' ? undefined : this.type,\n      uname:\n        this.portable ? undefined\n        : this.stat.uid === this.myuid ? this.myuser\n        : '',\n      atime: this.portable ? undefined : this.stat.atime,\n      ctime: this.portable ? undefined : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(\n        new Pax({\n          atime: this.portable ? undefined : this.header.atime,\n          ctime: this.portable ? undefined : this.header.ctime,\n          gid: this.portable ? undefined : this.header.gid,\n          mtime:\n            this.noMtime ? undefined : (\n              this.mtime || this.header.mtime\n            ),\n          path: this[PREFIX](this.path),\n          linkpath:\n            this.type === 'Link' && this.linkpath !== undefined ?\n              this[PREFIX](this.linkpath)\n            : this.linkpath,\n          size: this.header.size,\n          uid: this.portable ? undefined : this.header.uid,\n          uname: this.portable ? undefined : this.header.uname,\n          dev: this.portable ? undefined : this.stat.dev,\n          ino: this.portable ? undefined : this.stat.ino,\n          nlink: this.portable ? undefined : this.stat.nlink,\n        }).encode(),\n      )\n    }\n    const block = this.header?.block\n    /* c8 ignore start */\n    if (!block) {\n      throw new Error('failed to encode header')\n    }\n    /* c8 ignore stop */\n    super.write(block)\n  }\n\n  [DIRECTORY]() {\n    /* c8 ignore start */\n    if (!this.stat) {\n      throw new Error('cannot create directory entry without stat')\n    }\n    /* c8 ignore stop */\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK]() {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK](linkpath: string) {\n    this.linkpath = normalizeWindowsPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK](linkpath: string) {\n    /* c8 ignore start */\n    if (!this.stat) {\n      throw new Error('cannot create link entry without stat')\n    }\n    /* c8 ignore stop */\n    this.type = 'Link'\n    this.linkpath = normalizeWindowsPath(\n      path.relative(this.cwd, linkpath),\n    )\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE]() {\n    /* c8 ignore start */\n    if (!this.stat) {\n      throw new Error('cannot create file entry without stat')\n    }\n    /* c8 ignore stop */\n    if (this.stat.nlink > 1) {\n      const linkKey =\n        `${this.stat.dev}:${this.stat.ino}` as LinkCacheKey\n      const linkpath = this.linkCache.get(linkKey)\n      if (linkpath?.indexOf(this.cwd) === 0) {\n        return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE]() {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE](fd: number) {\n    this.fd = fd\n    if (this.#hadError) {\n      return this[CLOSE]()\n    }\n    /* c8 ignore start */\n    if (!this.stat) {\n      throw new Error('should stat before calling onopenfile')\n    }\n    /* c8 ignore start */\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ]() {\n    const { fd, buf, offset, length, pos } = this\n    if (fd === undefined || buf === undefined) {\n      throw new Error('cannot read file without first opening')\n    }\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  /* c8 ignore start */\n  [CLOSE](\n    cb: (er?: null | Error | NodeJS.ErrnoException) => any = () => {},\n  ) {\n    /* c8 ignore stop */\n    if (this.fd !== undefined) fs.close(this.fd, cb)\n  }\n\n  [ONREAD](bytesRead: number) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = Object.assign(\n        new Error('encountered unexpected EOF'),\n        {\n          path: this.absolute,\n          syscall: 'read',\n          code: 'EOF',\n        },\n      )\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = Object.assign(\n        new Error('did not encounter expected EOF'),\n        {\n          path: this.absolute,\n          syscall: 'read',\n          code: 'EOF',\n        },\n      )\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    /* c8 ignore start */\n    if (!this.buf) {\n      throw new Error('should have created buffer prior to reading')\n    }\n    /* c8 ignore stop */\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (\n        let i = bytesRead;\n        i < this.length && bytesRead < this.blockRemain;\n        i++\n      ) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const chunk =\n      this.offset === 0 && bytesRead === this.buf.length ?\n        this.buf\n      : this.buf.subarray(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(chunk)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN](cb: () => any) {\n    this.once('drain', cb)\n  }\n\n  write(buffer: Buffer | string, cb?: () => void): boolean\n  write(\n    str: Buffer | string,\n    encoding?: BufferEncoding | null,\n    cb?: () => void,\n  ): boolean\n  write(\n    chunk: Buffer | string,\n    encoding?: BufferEncoding | (() => any) | null,\n    cb?: () => any,\n  ): boolean {\n    /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(\n        chunk,\n        typeof encoding === 'string' ? encoding : 'utf8',\n      )\n    }\n    /* c8 ignore stop */\n\n    if (this.blockRemain < chunk.length) {\n      const er = Object.assign(\n        new Error('writing more data than expected'),\n        {\n          path: this.absolute,\n        },\n      )\n      return this.emit('error', er)\n    }\n    this.remain -= chunk.length\n    this.blockRemain -= chunk.length\n    this.pos += chunk.length\n    this.offset += chunk.length\n    return super.write(chunk, null, cb)\n  }\n\n  [ONDRAIN]() {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er =>\n        er ? this.emit('error', er) : this.end(),\n      )\n    }\n\n    /* c8 ignore start */\n    if (!this.buf) {\n      throw new Error('buffer lost somehow in ONDRAIN')\n    }\n    /* c8 ignore stop */\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(\n        Math.min(this.blockRemain, this.buf.length),\n      )\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n}\n\nexport class WriteEntrySync extends WriteEntry implements Warner {\n  sync: true = true;\n\n  [LSTAT]() {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK]() {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE]() {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ]() {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      /* c8 ignore start */\n      if (fd === undefined || buf === undefined) {\n        throw new Error('fd and buf must be set in READ method')\n      }\n      /* c8 ignore stop */\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN](cb: () => any) {\n    cb()\n  }\n\n  /* c8 ignore start */\n  [CLOSE](\n    cb: (er?: null | Error | NodeJS.ErrnoException) => any = () => {},\n  ) {\n    /* c8 ignore stop */\n    if (this.fd !== undefined) fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nexport class WriteEntryTar\n  extends Minipass<Buffer, Buffer | string, WarnEvent>\n  implements Warner\n{\n  blockLen: number = 0\n  blockRemain: number = 0\n  buf: number = 0\n  pos: number = 0\n  remain: number = 0\n  length: number = 0\n  preservePaths: boolean\n  portable: boolean\n  strict: boolean\n  noPax: boolean\n  noMtime: boolean\n  readEntry: ReadEntry\n  type: EntryTypeName\n  prefix?: string\n  path: string\n  mode?: number\n  uid?: number\n  gid?: number\n  uname?: string\n  gname?: string\n  header?: Header\n  mtime?: Date\n  atime?: Date\n  ctime?: Date\n  linkpath?: string\n  size: number\n  onWriteEntry?: (entry: WriteEntry) => any\n\n  warn(code: string, message: string | Error, data: WarnData = {}) {\n    return warnMethod(this, code, message, data)\n  }\n\n  constructor(\n    readEntry: ReadEntry,\n    opt_: TarOptionsWithAliases = {},\n  ) {\n    const opt = dealias(opt_)\n    super()\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.onWriteEntry = opt.onWriteEntry\n\n    this.readEntry = readEntry\n    const { type } = readEntry\n    /* c8 ignore start */\n    if (type === 'Unsupported') {\n      throw new Error('writing entry that should be ignored')\n    }\n    /* c8 ignore stop */\n    this.type = type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix\n\n    this.path = normalizeWindowsPath(readEntry.path)\n    this.mode =\n      readEntry.mode !== undefined ?\n        this[MODE](readEntry.mode)\n      : undefined\n    this.uid = this.portable ? undefined : readEntry.uid\n    this.gid = this.portable ? undefined : readEntry.gid\n    this.uname = this.portable ? undefined : readEntry.uname\n    this.gname = this.portable ? undefined : readEntry.gname\n    this.size = readEntry.size\n    this.mtime =\n      this.noMtime ? undefined : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? undefined : readEntry.atime\n    this.ctime = this.portable ? undefined : readEntry.ctime\n    this.linkpath =\n      readEntry.linkpath !== undefined ?\n        normalizeWindowsPath(readEntry.linkpath)\n      : undefined\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn: false | string = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root && typeof stripped === 'string') {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.onWriteEntry?.(this as unknown as WriteEntry)\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath:\n        this.type === 'Link' && this.linkpath !== undefined ?\n          this[PREFIX](this.linkpath)\n        : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? undefined : this.uid,\n      gid: this.portable ? undefined : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? undefined : this.mtime,\n      type: this.type,\n      uname: this.portable ? undefined : this.uname,\n      atime: this.portable ? undefined : this.atime,\n      ctime: this.portable ? undefined : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn(\n        'TAR_ENTRY_INFO',\n        `stripping ${pathWarn} from absolute path`,\n        {\n          entry: this,\n          path: pathWarn + this.path,\n        },\n      )\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(\n        new Pax({\n          atime: this.portable ? undefined : this.atime,\n          ctime: this.portable ? undefined : this.ctime,\n          gid: this.portable ? undefined : this.gid,\n          mtime: this.noMtime ? undefined : this.mtime,\n          path: this[PREFIX](this.path),\n          linkpath:\n            this.type === 'Link' && this.linkpath !== undefined ?\n              this[PREFIX](this.linkpath)\n            : this.linkpath,\n          size: this.size,\n          uid: this.portable ? undefined : this.uid,\n          uname: this.portable ? undefined : this.uname,\n          dev: this.portable ? undefined : this.readEntry.dev,\n          ino: this.portable ? undefined : this.readEntry.ino,\n          nlink: this.portable ? undefined : this.readEntry.nlink,\n        }).encode(),\n      )\n    }\n\n    const b = this.header?.block\n    /* c8 ignore start */\n    if (!b) throw new Error('failed to encode header')\n    /* c8 ignore stop */\n    super.write(b)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX](path: string) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE](mode: number) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write(buffer: Buffer | string, cb?: () => void): boolean\n  write(\n    str: Buffer | string,\n    encoding?: BufferEncoding | null,\n    cb?: () => void,\n  ): boolean\n  write(\n    chunk: Buffer | string,\n    encoding?: BufferEncoding | (() => any) | null,\n    cb?: () => any,\n  ): boolean {\n    /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(\n        chunk,\n        typeof encoding === 'string' ? encoding : 'utf8',\n      )\n    }\n    /* c8 ignore stop */\n    const writeLen = chunk.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(chunk, cb)\n  }\n\n  end(cb?: () => void): this\n  end(chunk: Buffer | string, cb?: () => void): this\n  end(\n    chunk: Buffer | string,\n    encoding?: BufferEncoding,\n    cb?: () => void,\n  ): this\n  end(\n    chunk?: Buffer | string | (() => void),\n    encoding?: BufferEncoding | (() => void),\n    cb?: () => void,\n  ): this {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n    if (typeof chunk === 'function') {\n      cb = chunk\n      encoding = undefined\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = undefined\n    }\n    if (typeof chunk === 'string') {\n      chunk = Buffer.from(chunk, encoding ?? 'utf8')\n    }\n    if (cb) this.once('finish', cb)\n    chunk ? super.end(chunk, cb) : super.end(cb)\n    /* c8 ignore stop */\n    return this\n  }\n}\n\nconst getType = (stat: Stats): EntryTypeName | 'Unsupported' =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n","export const modeFix = (\n  mode: number,\n  isDir: boolean,\n  portable: boolean,\n) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) & ~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400) {\n      mode |= 0o100\n    }\n    if (mode & 0o40) {\n      mode |= 0o10\n    }\n    if (mode & 0o4) {\n      mode |= 0o1\n    }\n  }\n  return mode\n}\n","// unix absolute paths are also absolute on win32, so we use this for both\nimport { win32 } from 'node:path'\nconst { isAbsolute, parse } = win32\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nexport const stripAbsolutePath = (path: string) => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root =\n      path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?\n        '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n","// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = ['|', '<', '>', '?', ':']\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)),\n)\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nexport const encode = (s: string) =>\n  raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s)\nexport const decode = (s: string) =>\n  win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s)\n","export class Yallist<T = unknown> {\n  tail?: Node<T>\n  head?: Node<T>\n  length: number = 0\n\n  static create<T = unknown>(list: Iterable<T> = []) {\n    return new Yallist(list)\n  }\n\n  constructor(list: Iterable<T> = []) {\n    for (const item of list) {\n      this.push(item)\n    }\n  }\n\n  *[Symbol.iterator]() {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n\n  removeNode(node: Node<T>) {\n    if (node.list !== this) {\n      throw new Error(\n        'removing node which does not belong to this list',\n      )\n    }\n\n    const next = node.next\n    const prev = node.prev\n\n    if (next) {\n      next.prev = prev\n    }\n\n    if (prev) {\n      prev.next = next\n    }\n\n    if (node === this.head) {\n      this.head = next\n    }\n    if (node === this.tail) {\n      this.tail = prev\n    }\n\n    this.length--\n    node.next = undefined\n    node.prev = undefined\n    node.list = undefined\n\n    return next\n  }\n\n  unshiftNode(node: Node<T>) {\n    if (node === this.head) {\n      return\n    }\n\n    if (node.list) {\n      node.list.removeNode(node)\n    }\n\n    const head = this.head\n    node.list = this\n    node.next = head\n    if (head) {\n      head.prev = node\n    }\n\n    this.head = node\n    if (!this.tail) {\n      this.tail = node\n    }\n    this.length++\n  }\n\n  pushNode(node: Node<T>) {\n    if (node === this.tail) {\n      return\n    }\n\n    if (node.list) {\n      node.list.removeNode(node)\n    }\n\n    const tail = this.tail\n    node.list = this\n    node.prev = tail\n    if (tail) {\n      tail.next = node\n    }\n\n    this.tail = node\n    if (!this.head) {\n      this.head = node\n    }\n    this.length++\n  }\n\n  push(...args: T[]) {\n    for (let i = 0, l = args.length; i < l; i++) {\n      push(this, args[i])\n    }\n    return this.length\n  }\n\n  unshift(...args: T[]) {\n    for (var i = 0, l = args.length; i < l; i++) {\n      unshift(this, args[i])\n    }\n    return this.length\n  }\n\n  pop() {\n    if (!this.tail) {\n      return undefined\n    }\n\n    const res = this.tail.value\n    const t = this.tail\n    this.tail = this.tail.prev\n    if (this.tail) {\n      this.tail.next = undefined\n    } else {\n      this.head = undefined\n    }\n    t.list = undefined\n    this.length--\n    return res\n  }\n\n  shift() {\n    if (!this.head) {\n      return undefined\n    }\n\n    const res = this.head.value\n    const h = this.head\n    this.head = this.head.next\n    if (this.head) {\n      this.head.prev = undefined\n    } else {\n      this.tail = undefined\n    }\n    h.list = undefined\n    this.length--\n    return res\n  }\n\n  forEach(\n    fn: (value: T, i: number, list: Yallist<T>) => any,\n    thisp?: any,\n  ) {\n    thisp = thisp || this\n    for (let walker = this.head, i = 0; !!walker; i++) {\n      fn.call(thisp, walker.value, i, this)\n      walker = walker.next\n    }\n  }\n\n  forEachReverse(\n    fn: (value: T, i: number, list: Yallist<T>) => any,\n    thisp?: any,\n  ) {\n    thisp = thisp || this\n    for (let walker = this.tail, i = this.length - 1; !!walker; i--) {\n      fn.call(thisp, walker.value, i, this)\n      walker = walker.prev\n    }\n  }\n\n  get(n: number) {\n    let i = 0\n    let walker = this.head\n    for (; !!walker && i < n; i++) {\n      walker = walker.next\n    }\n    if (i === n && !!walker) {\n      return walker.value\n    }\n  }\n\n  getReverse(n: number) {\n    let i = 0\n    let walker = this.tail\n    for (; !!walker && i < n; i++) {\n      // abort out of the list early if we hit a cycle\n      walker = walker.prev\n    }\n    if (i === n && !!walker) {\n      return walker.value\n    }\n  }\n\n  map<R = any>(\n    fn: (value: T, list: Yallist<T>) => R,\n    thisp?: any,\n  ): Yallist<R> {\n    thisp = thisp || this\n    const res = new Yallist<R>()\n    for (let walker = this.head; !!walker; ) {\n      res.push(fn.call(thisp, walker.value, this))\n      walker = walker.next\n    }\n    return res\n  }\n\n  mapReverse<R = any>(\n    fn: (value: T, list: Yallist<T>) => R,\n    thisp?: any,\n  ): Yallist<R> {\n    thisp = thisp || this\n    var res = new Yallist<R>()\n    for (let walker = this.tail; !!walker; ) {\n      res.push(fn.call(thisp, walker.value, this))\n      walker = walker.prev\n    }\n    return res\n  }\n\n  reduce(fn: (left: T, right: T, i: number) => T): T\n  reduce<R = any>(\n    fn: (acc: R, next: T, i: number) => R,\n    initial: R,\n  ): R\n  reduce<R = any>(\n    fn: (acc: R, next: T, i: number) => R,\n    initial?: R,\n  ): R {\n    let acc: R | T\n    let walker = this.head\n    if (arguments.length > 1) {\n      acc = initial as R\n    } else if (this.head) {\n      walker = this.head.next\n      acc = this.head.value\n    } else {\n      throw new TypeError(\n        'Reduce of empty list with no initial value',\n      )\n    }\n\n    for (var i = 0; !!walker; i++) {\n      acc = fn(acc as R, walker.value, i)\n      walker = walker.next\n    }\n\n    return acc as R\n  }\n\n  reduceReverse(fn: (left: T, right: T, i: number) => T): T\n  reduceReverse<R = any>(\n    fn: (acc: R, next: T, i: number) => R,\n    initial: R,\n  ): R\n  reduceReverse<R = any>(\n    fn: (acc: R, next: T, i: number) => R,\n    initial?: R,\n  ): R {\n    let acc: R | T\n    let walker = this.tail\n    if (arguments.length > 1) {\n      acc = initial as R\n    } else if (this.tail) {\n      walker = this.tail.prev\n      acc = this.tail.value\n    } else {\n      throw new TypeError(\n        'Reduce of empty list with no initial value',\n      )\n    }\n\n    for (let i = this.length - 1; !!walker; i--) {\n      acc = fn(acc as R, walker.value, i)\n      walker = walker.prev\n    }\n\n    return acc as R\n  }\n\n  toArray() {\n    const arr = new Array(this.length)\n    for (let i = 0, walker = this.head; !!walker; i++) {\n      arr[i] = walker.value\n      walker = walker.next\n    }\n    return arr\n  }\n\n  toArrayReverse() {\n    const arr = new Array(this.length)\n    for (let i = 0, walker = this.tail; !!walker; i++) {\n      arr[i] = walker.value\n      walker = walker.prev\n    }\n    return arr\n  }\n\n  slice(from: number = 0, to: number = this.length) {\n    if (to < 0) {\n      to += this.length\n    }\n    if (from < 0) {\n      from += this.length\n    }\n    const ret = new Yallist()\n    if (to < from || to < 0) {\n      return ret\n    }\n    if (from < 0) {\n      from = 0\n    }\n    if (to > this.length) {\n      to = this.length\n    }\n    let walker = this.head\n    let i = 0\n    for (i = 0; !!walker && i < from; i++) {\n      walker = walker.next\n    }\n    for (; !!walker && i < to; i++, walker = walker.next) {\n      ret.push(walker.value)\n    }\n    return ret\n  }\n\n  sliceReverse(from: number = 0, to: number = this.length) {\n    if (to < 0) {\n      to += this.length\n    }\n    if (from < 0) {\n      from += this.length\n    }\n    const ret = new Yallist()\n    if (to < from || to < 0) {\n      return ret\n    }\n    if (from < 0) {\n      from = 0\n    }\n    if (to > this.length) {\n      to = this.length\n    }\n    let i = this.length\n    let walker = this.tail\n    for (; !!walker && i > to; i--) {\n      walker = walker.prev\n    }\n    for (; !!walker && i > from; i--, walker = walker.prev) {\n      ret.push(walker.value)\n    }\n    return ret\n  }\n\n  splice(start: number, deleteCount: number = 0, ...nodes: T[]) {\n    if (start > this.length) {\n      start = this.length - 1\n    }\n    if (start < 0) {\n      start = this.length + start\n    }\n\n    let walker = this.head\n\n    for (let i = 0; !!walker && i < start; i++) {\n      walker = walker.next\n    }\n\n    const ret: T[] = []\n    for (let i = 0; !!walker && i < deleteCount; i++) {\n      ret.push(walker.value)\n      walker = this.removeNode(walker)\n    }\n    if (!walker) {\n      walker = this.tail\n    } else if (walker !== this.tail) {\n      walker = walker.prev\n    }\n\n    for (const v of nodes) {\n      walker = insertAfter<T>(this, walker, v)\n    }\n\n    return ret\n  }\n\n  reverse() {\n    const head = this.head\n    const tail = this.tail\n    for (let walker = head; !!walker; walker = walker.prev) {\n      const p = walker.prev\n      walker.prev = walker.next\n      walker.next = p\n    }\n    this.head = tail\n    this.tail = head\n    return this\n  }\n}\n\n// insertAfter undefined means \"make the node the new head of list\"\nfunction insertAfter<T>(\n  self: Yallist<T>,\n  node: Node<T> | undefined,\n  value: T,\n) {\n  const prev = node\n  const next = node ? node.next : self.head\n  const inserted = new Node<T>(value, prev, next, self)\n\n  if (inserted.next === undefined) {\n    self.tail = inserted\n  }\n  if (inserted.prev === undefined) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push<T>(self: Yallist<T>, item: T) {\n  self.tail = new Node<T>(item, self.tail, undefined, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift<T>(self: Yallist<T>, item: T) {\n  self.head = new Node<T>(item, undefined, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nexport class Node<T = unknown> {\n  list?: Yallist<T>\n  next?: Node<T>\n  prev?: Node<T>\n  value: T\n\n  constructor(\n    value: T,\n    prev?: Node<T> | undefined,\n    next?: Node<T> | undefined,\n    list?: Yallist<T> | undefined,\n  ) {\n    this.list = list\n    this.value = value\n\n    if (prev) {\n      prev.next = this\n      this.prev = prev\n    } else {\n      this.prev = undefined\n    }\n\n    if (next) {\n      next.prev = this\n      this.next = next\n    } else {\n      this.next = undefined\n    }\n  }\n}\n","// tar -x\nimport * as fsm from '@isaacs/fs-minipass'\nimport fs from 'node:fs'\nimport { filesFilter } from './list.js'\nimport { makeCommand } from './make-command.js'\nimport { TarOptionsFile, TarOptionsSyncFile } from './options.js'\nimport { Unpack, UnpackSync } from './unpack.js'\n\nconst extractFileSync = (opt: TarOptionsSyncFile) => {\n  const u = new UnpackSync(opt)\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt: TarOptionsFile, _?: string[]) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise<void>((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return p\n}\n\nexport const extract = makeCommand<Unpack, UnpackSync>(\n  extractFileSync,\n  extractFile,\n  opt => new UnpackSync(opt),\n  opt => new Unpack(opt),\n  (opt, files) => {\n    if (files?.length) filesFilter(opt, files)\n  },\n)\n","// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nimport * as fsm from '@isaacs/fs-minipass'\nimport assert from 'node:assert'\nimport { randomBytes } from 'node:crypto'\nimport fs, { type Stats } from 'node:fs'\nimport path from 'node:path'\nimport { getWriteFlag } from './get-write-flag.js'\nimport { mkdir, MkdirError, mkdirSync } from './mkdir.js'\nimport { normalizeWindowsPath } from './normalize-windows-path.js'\nimport { Parser } from './parse.js'\nimport { stripAbsolutePath } from './strip-absolute-path.js'\nimport * as wc from './winchars.js'\n\nimport { TarOptions } from './options.js'\nimport { PathReservations } from './path-reservations.js'\nimport { ReadEntry } from './read-entry.js'\nimport { WarnData } from './warn-method.js'\nimport { SymlinkError } from './symlink-error.js'\nimport { umask } from './process-umask.js'\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst ENSURE_NO_SYMLINK = Symbol('ensureNoSymlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst STRIPABSOLUTEPATH = Symbol('stripAbsolutePath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst platform =\n  process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\nconst DEFAULT_MAX_DEPTH = 1024\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* c8 ignore start */\nconst unlinkFile = (\n  path: string,\n  cb: (er?: Error | null) => void,\n) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */\nconst unlinkFileSync = (path: string) => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n/* c8 ignore stop */\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (\n  a: number | undefined,\n  b: number | undefined,\n  c: number | undefined,\n) =>\n  a !== undefined && a === a >>> 0 ? a\n  : b !== undefined && b === b >>> 0 ? b\n  : c\n\nexport class Unpack extends Parser {\n  [ENDED]: boolean = false;\n  [CHECKED_CWD]: boolean = false;\n  [PENDING]: number = 0\n\n  reservations: PathReservations = new PathReservations()\n  transform?: TarOptions['transform']\n  writable: true = true\n  readable: false = false\n  uid?: number\n  gid?: number\n  setOwner: boolean\n  preserveOwner: boolean\n  processGid?: number\n  processUid?: number\n  maxDepth: number\n  forceChown: boolean\n  win32: boolean\n  newer: boolean\n  keep: boolean\n  noMtime: boolean\n  preservePaths: boolean\n  unlink: boolean\n  cwd: string\n  strip: number\n  processUmask: number\n  umask: number\n  dmode: number\n  fmode: number\n  chmod: boolean\n\n  constructor(opt: TarOptions = {}) {\n    opt.ondone = () => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.transform = opt.transform\n\n    this.chmod = !!opt.chmod\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (\n        typeof opt.uid !== 'number' ||\n        typeof opt.gid !== 'number'\n      ) {\n        throw new TypeError(\n          'cannot set owner without number uid and gid',\n        )\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly',\n        )\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = undefined\n      this.gid = undefined\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (\n      opt.preserveOwner === undefined &&\n      typeof opt.uid !== 'number'\n    ) {\n      this.preserveOwner = !!(\n        process.getuid && process.getuid() === 0\n      )\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid =\n      (this.preserveOwner || this.setOwner) && process.getuid ?\n        process.getuid()\n      : undefined\n    this.processGid =\n      (this.preserveOwner || this.setOwner) && process.getgid ?\n        process.getgid()\n      : undefined\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth =\n      typeof opt.maxDepth === 'number' ?\n        opt.maxDepth\n      : DEFAULT_MAX_DEPTH\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normalizeWindowsPath(\n      path.resolve(opt.cwd || process.cwd()),\n    )\n    this.strip = Number(opt.strip) || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask =\n      !this.chmod ? 0\n      : typeof opt.processUmask === 'number' ? opt.processUmask\n      : umask()\n    this.umask =\n      typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || 0o0777 & ~this.umask\n    this.fmode = opt.fmode || 0o0666 & ~this.umask\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn(code: string, msg: string | Error, data: WarnData = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  // return false if we need to skip this file\n  // return true if the field was successfully sanitized\n  [STRIPABSOLUTEPATH](\n    entry: ReadEntry,\n    field: 'path' | 'linkpath',\n  ): boolean {\n    const p = entry[field]\n    const { type } = entry\n    if (!p || this.preservePaths) return true\n\n    const parts = p.split('/')\n\n    if (\n      parts.includes('..') ||\n      /* c8 ignore next */\n      (isWindows && /^[a-z]:\\.\\.$/i.test(parts[0] ?? ''))\n    ) {\n      // For linkpath, check if the resolved path escapes cwd rather than\n      // just rejecting any path with '..' - relative symlinks like\n      // '../sibling/file' are valid if they resolve within the cwd.\n      // For paths, they just simply may not ever use .. at all.\n      if (field === 'path' || type === 'Link') {\n        this.warn('TAR_ENTRY_ERROR', `${field} contains '..'`, {\n          entry,\n          [field]: p,\n        })\n        // not ok!\n        return false\n      } else {\n        // Resolve linkpath relative to the entry's directory.\n        // `path.posix` is safe to use because we're operating on\n        // tar paths, not a filesystem.\n        const entryDir = path.posix.dirname(entry.path)\n        const resolved = path.posix.normalize(\n          path.posix.join(entryDir, p),\n        )\n        // If the resolved path escapes (starts with ..), reject it\n        if (resolved.startsWith('../') || resolved === '..') {\n          this.warn(\n            'TAR_ENTRY_ERROR',\n            `${field} escapes extraction directory`,\n            {\n              entry,\n              [field]: p,\n            },\n          )\n          return false\n        }\n      }\n    }\n\n    // strip off the root\n    const [root, stripped] = stripAbsolutePath(p)\n    if (root) {\n      // ok, but triggers warning about stripping root\n      entry[field] = String(stripped)\n      this.warn(\n        'TAR_ENTRY_INFO',\n        `stripping ${root} from absolute ${field}`,\n        {\n          entry,\n          [field]: p,\n        },\n      )\n    }\n    return true\n  }\n\n  // no IO, just string checking for absolute indicators\n  [CHECKPATH](entry: ReadEntry) {\n    const p = normalizeWindowsPath(entry.path)\n    const parts = p.split('/')\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normalizeWindowsPath(\n          String(entry.linkpath),\n        ).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n      parts.splice(0, this.strip)\n      entry.path = parts.join('/')\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth,\n      })\n      return false\n    }\n\n    if (\n      !this[STRIPABSOLUTEPATH](entry, 'path') ||\n      !this[STRIPABSOLUTEPATH](entry, 'linkpath')\n    ) {\n      return false\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normalizeWindowsPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normalizeWindowsPath(\n        path.resolve(this.cwd, entry.path),\n      )\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* c8 ignore start - defense in depth */\n    if (\n      !this.preservePaths &&\n      typeof entry.absolute === 'string' &&\n      entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n      entry.absolute !== this.cwd\n    ) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normalizeWindowsPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n    /* c8 ignore stop */\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (\n      entry.absolute === this.cwd &&\n      entry.type !== 'Directory' &&\n      entry.type !== 'GNUDumpDir'\n    ) {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(String(entry.absolute))\n      entry.absolute =\n        aRoot + wc.encode(String(entry.absolute).slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY](entry: ReadEntry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR](er: Error, entry: ReadEntry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR](\n    dir: string,\n    mode: number,\n    cb: (er?: null | MkdirError, made?: string) => void,\n  ) {\n    mkdir(\n      normalizeWindowsPath(dir),\n      {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cwd: this.cwd,\n        mode: mode,\n      },\n      cb,\n    )\n  }\n\n  [DOCHOWN](entry: ReadEntry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return (\n      this.forceChown ||\n      (this.preserveOwner &&\n        ((typeof entry.uid === 'number' &&\n          entry.uid !== this.processUid) ||\n          (typeof entry.gid === 'number' &&\n            entry.gid !== this.processGid))) ||\n      (typeof this.uid === 'number' &&\n        this.uid !== this.processUid) ||\n      (typeof this.gid === 'number' && this.gid !== this.processGid)\n    )\n  }\n\n  [UID](entry: ReadEntry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID](entry: ReadEntry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE](entry: ReadEntry, fullyDone: () => void) {\n    const mode =\n      typeof entry.mode === 'number' ?\n        entry.mode & 0o7777\n      : this.fmode\n    const stream = new fsm.WriteStream(String(entry.absolute), {\n      // slight lie, but it can be numeric flags\n      flags: getWriteFlag(entry.size) as string,\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', (er: Error) => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = (er?: null | Error) => {\n      if (er) {\n        /* c8 ignore start - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n        /* c8 ignore stop */\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        if (stream.fd !== undefined) {\n          fs.close(stream.fd, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n            } else {\n              this[UNPEND]()\n            }\n            fullyDone()\n          })\n        }\n      }\n    }\n\n    stream.on('finish', () => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = String(entry.absolute)\n      const fd = stream.fd\n\n      if (typeof fd === 'number' && entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ?\n            fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done(),\n        )\n      }\n\n      if (typeof fd === 'number' && this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        if (typeof uid === 'number' && typeof gid === 'number') {\n          fs.fchown(fd, uid, gid, er =>\n            er ?\n              fs.chown(abs, uid, gid, er2 => done(er2 && er))\n            : done(),\n          )\n        }\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', (er: Error) => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY](entry: ReadEntry, fullyDone: () => void) {\n    const mode =\n      typeof entry.mode === 'number' ?\n        entry.mode & 0o7777\n      : this.dmode\n    this[MKDIR](String(entry.absolute), mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = () => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(\n          String(entry.absolute),\n          entry.atime || new Date(),\n          entry.mtime,\n          done,\n        )\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(\n          String(entry.absolute),\n          Number(this[UID](entry)),\n          Number(this[GID](entry)),\n          done,\n        )\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED](entry: ReadEntry) {\n    entry.unsupported = true\n    this.warn(\n      'TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`,\n      { entry },\n    )\n    entry.resume()\n  }\n\n  [SYMLINK](entry: ReadEntry, done: () => void) {\n    const parts = normalizeWindowsPath(\n      path.relative(\n        this.cwd,\n        path.resolve(\n          path.dirname(String(entry.absolute)),\n          String(entry.linkpath),\n        ),\n      ),\n    ).split('/')\n    this[ENSURE_NO_SYMLINK](\n      entry,\n      this.cwd,\n      parts,\n      () =>\n        this[LINK](entry, String(entry.linkpath), 'symlink', done),\n      er => {\n        this[ONERROR](er, entry)\n        done()\n      },\n    )\n  }\n\n  [HARDLINK](entry: ReadEntry, done: () => void) {\n    const linkpath = normalizeWindowsPath(\n      path.resolve(this.cwd, String(entry.linkpath)),\n    )\n    const parts = normalizeWindowsPath(String(entry.linkpath)).split(\n      '/',\n    )\n    this[ENSURE_NO_SYMLINK](\n      entry,\n      this.cwd,\n      parts,\n      () => this[LINK](entry, linkpath, 'link', done),\n      er => {\n        this[ONERROR](er, entry)\n        done()\n      },\n    )\n  }\n\n  [ENSURE_NO_SYMLINK](\n    entry: ReadEntry,\n    cwd: string,\n    parts: string[],\n    done: () => void,\n    onError: (er: SymlinkError) => void,\n  ) {\n    const p = parts.shift()\n    if (this.preservePaths || p === undefined) return done()\n    const t = path.resolve(cwd, p)\n    fs.lstat(t, (er, st) => {\n      if (er) return done()\n      if (st?.isSymbolicLink()) {\n        return onError(\n          new SymlinkError(t, path.resolve(t, parts.join('/'))),\n        )\n      }\n      this[ENSURE_NO_SYMLINK](entry, t, parts, done, onError)\n    })\n  }\n\n  [PEND]() {\n    this[PENDING]++\n  }\n\n  [UNPEND]() {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP](entry: ReadEntry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE](entry: ReadEntry, st: Stats) {\n    return (\n      entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n    )\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS](entry: ReadEntry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done =>\n      this[CHECKFS2](entry, done),\n    )\n  }\n\n  [CHECKFS2](entry: ReadEntry, fullyDone: (er?: Error) => void) {\n    const done = (er?: Error) => {\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normalizeWindowsPath(\n          path.dirname(String(entry.absolute)),\n        )\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(String(entry.absolute), (lstatEr, st) => {\n        if (\n          st &&\n          (this.keep ||\n            /* c8 ignore next */\n            (this.newer && st.mtime > (entry.mtime ?? st.mtime)))\n        ) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod =\n              this.chmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = (er?: Error | null | undefined) =>\n              this[MAKEFS](er ?? null, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(\n              String(entry.absolute),\n              Number(entry.mode),\n              afterChmod,\n            )\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(\n              String(entry.absolute),\n              (er?: null | Error) =>\n                this[MAKEFS](er ?? null, entry, done),\n            )\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(String(entry.absolute), er =>\n          this[MAKEFS](er ?? null, entry, done),\n        )\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS](\n    er: null | undefined | Error,\n    entry: ReadEntry,\n    done: () => void,\n  ) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK](\n    entry: ReadEntry,\n    linkpath: string,\n    link: 'link' | 'symlink',\n    done: () => void,\n  ) {\n    fs[link](linkpath, String(entry.absolute), er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = <T>(\n  fn: () => T,\n): [null, T] | [NodeJS.ErrnoException, null] => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er as NodeJS.ErrnoException, null]\n  }\n}\n\nexport class UnpackSync extends Unpack {\n  sync: true = true;\n\n  [MAKEFS](er: null | Error | undefined, entry: ReadEntry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS](entry: ReadEntry) {\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er as Error, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normalizeWindowsPath(\n        path.dirname(String(entry.absolute)),\n      )\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent as Error, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() =>\n      fs.lstatSync(String(entry.absolute)),\n    )\n    if (\n      st &&\n      (this.keep ||\n        /* c8 ignore next */\n        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))\n    ) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod =\n          this.chmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] =\n          needChmod ?\n            callSync(() => {\n              fs.chmodSync(String(entry.absolute), Number(entry.mode))\n            })\n          : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() =>\n        fs.rmdirSync(String(entry.absolute)),\n      )\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] =\n      entry.absolute === this.cwd ?\n        []\n      : callSync(() => unlinkFileSync(String(entry.absolute)))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE](entry: ReadEntry, done: () => void) {\n    const mode =\n      typeof entry.mode === 'number' ?\n        entry.mode & 0o7777\n      : this.fmode\n\n    const oner = (er?: null | Error | undefined) => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR]((er as Error) || closeError, entry)\n      }\n      done()\n    }\n\n    let fd: number\n    try {\n      fd = fs.openSync(\n        String(entry.absolute),\n        getWriteFlag(entry.size),\n        mode,\n      )\n      /* c8 ignore start - This is only a problem if the file was successfully\n       * statted, BUT failed to open. Testing this is annoying, and we\n       * already have ample testint for other uses of oner() methods.\n       */\n    } catch (er) {\n      return oner(er as Error)\n    }\n    /* c8 ignore stop */\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', (er: Error) => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', (chunk: Buffer) => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er as Error)\n      }\n    })\n\n    tx.on('end', () => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(String(entry.absolute), atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, Number(uid), Number(gid))\n        } catch (fchowner) {\n          try {\n            fs.chownSync(\n              String(entry.absolute),\n              Number(uid),\n              Number(gid),\n            )\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er as Error)\n    })\n  }\n\n  [DIRECTORY](entry: ReadEntry, done: () => void) {\n    const mode =\n      typeof entry.mode === 'number' ?\n        entry.mode & 0o7777\n      : this.dmode\n    const er = this[MKDIR](String(entry.absolute), mode)\n    if (er) {\n      this[ONERROR](er as Error, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(\n          String(entry.absolute),\n          entry.atime || new Date(),\n          entry.mtime,\n        )\n        /* c8 ignore next */\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(\n          String(entry.absolute),\n          Number(this[UID](entry)),\n          Number(this[GID](entry)),\n        )\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR](dir: string, mode: number) {\n    try {\n      return mkdirSync(normalizeWindowsPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [ENSURE_NO_SYMLINK](\n    _entry: ReadEntry,\n    cwd: string,\n    parts: string[],\n    done: () => void,\n    onError: (er: SymlinkError) => void,\n  ) {\n    if (this.preservePaths || !parts.length) return done()\n    let t = cwd\n    for (const p of parts) {\n      t = path.resolve(t, p)\n      const [er, st] = callSync(() => fs.lstatSync(t))\n      if (er) return done()\n      if (st.isSymbolicLink()) {\n        return onError(\n          new SymlinkError(t, path.resolve(cwd, parts.join('/'))),\n        )\n      }\n    }\n    done()\n  }\n\n  [LINK](\n    entry: ReadEntry,\n    linkpath: string,\n    link: 'link' | 'symlink',\n    done: () => void,\n  ) {\n    const linkSync: `${typeof link}Sync` = `${link}Sync`\n    try {\n      fs[linkSync](linkpath, String(entry.absolute))\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er as Error, entry)\n    }\n  }\n}\n","// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n\nimport fs from 'fs'\n\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\n\n/* c8 ignore start */\nconst { O_CREAT, O_TRUNC, O_WRONLY } = fs.constants\nconst UV_FS_O_FILEMAP =\n  Number(process.env.__FAKE_FS_O_FILENAME__) ||\n  fs.constants.UV_FS_O_FILEMAP ||\n  0\n/* c8 ignore stop */\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nexport const getWriteFlag =\n  !fMapEnabled ?\n    () => 'w'\n  : (size: number) => (size < fMapLimit ? fMapFlag : 'w')\n","import fs, { type Dirent } from 'node:fs'\nimport path from 'node:path'\n\nconst lchownSync = (path: string, uid: number, gid: number) => {\n  try {\n    return fs.lchownSync(path, uid, gid)\n  } catch (er) {\n    if ((er as NodeJS.ErrnoException)?.code !== 'ENOENT') throw er\n  }\n}\n\nconst chown = (\n  cpath: string,\n  uid: number,\n  gid: number,\n  cb: (er?: unknown) => any,\n) => {\n  fs.lchown(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && (er as NodeJS.ErrnoException)?.code !== 'ENOENT' ? er : null)\n  })\n}\n\nconst chownrKid = (\n  p: string,\n  child: Dirent,\n  uid: number,\n  gid: number,\n  cb: (er?: unknown) => any,\n) => {\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, (er: unknown) => {\n      if (er) return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\nexport const chownr = (\n  p: string,\n  uid: number,\n  gid: number,\n  cb: (er?: unknown) => any,\n) => {\n  fs.readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT') return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length) return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState: null | NodeJS.ErrnoException = null\n    const then = (er?: unknown) => {\n      /* c8 ignore start */\n      if (errState) return\n      /* c8 ignore stop */\n      if (er) return cb((errState = er as NodeJS.ErrnoException))\n      if (--len === 0) return chown(p, uid, gid, cb)\n    }\n\n    for (const child of children) {\n      chownrKid(p, child, uid, gid, then)\n    }\n  })\n}\n\nconst chownrKidSync = (\n  p: string,\n  child: Dirent,\n  uid: number,\n  gid: number,\n) => {\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  lchownSync(path.resolve(p, child.name), uid, gid)\n}\n\nexport const chownrSync = (p: string, uid: number, gid: number) => {\n  let children: Dirent[]\n  try {\n    children = fs.readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    const e = er as NodeJS.ErrnoException\n    if (e?.code === 'ENOENT') return\n    else if (e?.code === 'ENOTDIR' || e?.code === 'ENOTSUP')\n      return lchownSync(p, uid, gid)\n    else throw e\n  }\n\n  for (const child of children) {\n    chownrKidSync(p, child, uid, gid)\n  }\n\n  return lchownSync(p, uid, gid)\n}\n","import { chownr, chownrSync } from 'chownr'\nimport fs from 'node:fs'\nimport fsp from 'node:fs/promises'\nimport path from 'node:path'\nimport { CwdError } from './cwd-error.js'\nimport { normalizeWindowsPath } from './normalize-windows-path.js'\nimport { SymlinkError } from './symlink-error.js'\n\nexport type MkdirOptions = {\n  uid?: number\n  gid?: number\n  processUid?: number\n  processGid?: number\n  umask?: number\n  preserve: boolean\n  unlink: boolean\n  cwd: string\n  mode: number\n}\n\nexport type MkdirError =\n  | NodeJS.ErrnoException\n  | CwdError\n  | SymlinkError\n\nconst checkCwd = (\n  dir: string,\n  cb: (er?: null | MkdirError) => any,\n) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(\n        dir,\n        (er as NodeJS.ErrnoException)?.code || 'ENOTDIR',\n      )\n    }\n    cb(er)\n  })\n}\n\n/**\n * Wrapper around fs/promises.mkdir for tar's needs.\n *\n * The main purpose is to avoid creating directories if we know that\n * they already exist (and track which ones exist for this purpose),\n * and prevent entries from being extracted into symlinked folders,\n * if `preservePaths` is not set.\n */\nexport const mkdir = (\n  dir: string,\n  opt: MkdirOptions,\n  cb: (er?: null | MkdirError, made?: string) => void,\n) => {\n  dir = normalizeWindowsPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  /* c8 ignore next */\n  const umask = opt.umask ?? 0o22\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown =\n    typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cwd = normalizeWindowsPath(opt.cwd)\n\n  const done = (er?: null | MkdirError, created?: string) => {\n    if (er) {\n      cb(er)\n    } else {\n      if (created && doChown) {\n        chownr(created, uid, gid, er =>\n          done(er as NodeJS.ErrnoException),\n        )\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return fsp.mkdir(dir, { mode, recursive: true }).then(\n      made => done(null, made ?? undefined), // oh, ts\n      done,\n    )\n  }\n\n  const sub = normalizeWindowsPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, unlink, cwd, undefined, done)\n}\n\nconst mkdir_ = (\n  base: string,\n  parts: string[],\n  mode: number,\n  unlink: boolean,\n  cwd: string,\n  created: string | undefined,\n  cb: (er?: null | MkdirError, made?: string) => void,\n): void => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normalizeWindowsPath(path.resolve(base + '/' + p))\n  fs.mkdir(\n    part,\n    mode,\n    onmkdir(part, parts, mode, unlink, cwd, created, cb),\n  )\n}\n\nconst onmkdir =\n  (\n    part: string,\n    parts: string[],\n    mode: number,\n    unlink: boolean,\n    cwd: string,\n    created: string | undefined,\n    cb: (er?: null | MkdirError, made?: string) => void,\n  ) =>\n  (er?: null | NodeJS.ErrnoException) => {\n    if (er) {\n      fs.lstat(part, (statEr, st) => {\n        if (statEr) {\n          statEr.path =\n            statEr.path && normalizeWindowsPath(statEr.path)\n          cb(statEr)\n        } else if (st.isDirectory()) {\n          mkdir_(part, parts, mode, unlink, cwd, created, cb)\n        } else if (unlink) {\n          fs.unlink(part, er => {\n            if (er) {\n              return cb(er)\n            }\n            fs.mkdir(\n              part,\n              mode,\n              onmkdir(part, parts, mode, unlink, cwd, created, cb),\n            )\n          })\n        } else if (st.isSymbolicLink()) {\n          return cb(\n            new SymlinkError(part, part + '/' + parts.join('/')),\n          )\n        } else {\n          cb(er)\n        }\n      })\n    } else {\n      created = created || part\n      mkdir_(part, parts, mode, unlink, cwd, created, cb)\n    }\n  }\n\nconst checkCwdSync = (dir: string) => {\n  let ok = false\n  let code: string | undefined = undefined\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = (er as NodeJS.ErrnoException)?.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code ?? 'ENOTDIR')\n    }\n  }\n}\n\nexport const mkdirSync = (dir: string, opt: MkdirOptions) => {\n  dir = normalizeWindowsPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  /* c8 ignore next */\n  const umask = opt.umask ?? 0o22\n  const mode = opt.mode | 0o700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown =\n    typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cwd = normalizeWindowsPath(opt.cwd)\n\n  const done = (created?: string | undefined) => {\n    if (created && doChown) {\n      chownrSync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(\n      fs.mkdirSync(dir, { mode, recursive: true }) ?? undefined,\n    )\n  }\n\n  const sub = normalizeWindowsPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created: string | undefined = undefined\n  for (\n    let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()\n  ) {\n    part = normalizeWindowsPath(path.resolve(part))\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n","export class CwdError extends Error {\n  path: string\n  code: string\n  syscall: 'chdir' = 'chdir'\n\n  constructor(path: string, code: string) {\n    super(`${code}: Cannot cd into '${path}'`)\n    this.path = path\n    this.code = code\n  }\n\n  get name() {\n    return 'CwdError'\n  }\n}\n","export class SymlinkError extends Error {\n  path: string\n  symlink: string\n  syscall: 'symlink' = 'symlink'\n  code: 'TAR_SYMLINK_ERROR' = 'TAR_SYMLINK_ERROR'\n  constructor(symlink: string, path: string) {\n    super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link')\n    this.symlink = symlink\n    this.path = path\n  }\n  get name() {\n    return 'SymlinkError'\n  }\n}\n","// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nimport { join } from 'node:path'\nimport { normalizeUnicode } from './normalize-unicode.js'\nimport { stripTrailingSlashes } from './strip-trailing-slashes.js'\n\nconst platform =\n  process.env.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nexport type Reservation = {\n  paths: string[]\n  dirs: Set<string>\n}\n\nexport type Handler = (clear: () => void) => void\n\n// return a set of parent dirs for a given path\n// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\nconst getDirs = (path: string) => {\n  const dirs = path\n    .split('/')\n    .slice(0, -1)\n    .reduce((set: string[], path) => {\n      const s = set[set.length - 1]\n      if (s !== undefined) {\n        path = join(s, path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n  return dirs\n}\n\nexport class PathReservations {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  #queues = new Map<string, (Handler | Set<Handler>)[]>()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  #reservations = new Map<Handler, Reservation>()\n\n  // functions currently running\n  #running = new Set<Handler>()\n\n  reserve(paths: string[], fn: Handler) {\n    paths =\n      isWindows ?\n        ['win32 parallelization disabled']\n      : paths.map(p => {\n          // don't need normPath, because we skip this entirely for windows\n          return stripTrailingSlashes(join(normalizeUnicode(p)))\n        })\n\n    const dirs = new Set<string>(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)),\n    )\n    this.#reservations.set(fn, { dirs, paths })\n    for (const p of paths) {\n      const q = this.#queues.get(p)\n      if (!q) {\n        this.#queues.set(p, [fn])\n      } else {\n        q.push(fn)\n      }\n    }\n    for (const dir of dirs) {\n      const q = this.#queues.get(dir)\n      if (!q) {\n        this.#queues.set(dir, [new Set([fn])])\n      } else {\n        const l = q[q.length - 1]\n        if (l instanceof Set) {\n          l.add(fn)\n        } else {\n          q.push(new Set([fn]))\n        }\n      }\n    }\n    return this.#run(fn)\n  }\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  #getQueues(fn: Handler): {\n    paths: Handler[][]\n    dirs: (Handler | Set<Handler>)[][]\n  } {\n    const res = this.#reservations.get(fn)\n    /* c8 ignore start */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    /* c8 ignore stop */\n    return {\n      paths: res.paths.map((path: string) =>\n        this.#queues.get(path),\n      ) as Handler[][],\n      dirs: [...res.dirs].map(path => this.#queues.get(path)) as (\n        | Handler\n        | Set<Handler>\n      )[][],\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  check(fn: Handler) {\n    const { paths, dirs } = this.#getQueues(fn)\n    return (\n      paths.every(q => q && q[0] === fn) &&\n      dirs.every(q => q && q[0] instanceof Set && q[0].has(fn))\n    )\n  }\n\n  // run the function if it's first in line and not already running\n  #run(fn: Handler) {\n    if (this.#running.has(fn) || !this.check(fn)) {\n      return false\n    }\n    this.#running.add(fn)\n    fn(() => this.#clear(fn))\n    return true\n  }\n\n  #clear(fn: Handler) {\n    if (!this.#running.has(fn)) {\n      return false\n    }\n    const res = this.#reservations.get(fn)\n    /* c8 ignore start */\n    if (!res) {\n      throw new Error('invalid reservation')\n    }\n    /* c8 ignore stop */\n    const { paths, dirs } = res\n\n    const next = new Set<Handler>()\n    for (const path of paths) {\n      const q = this.#queues.get(path)\n      /* c8 ignore start */\n      if (!q || q?.[0] !== fn) {\n        continue\n      }\n      /* c8 ignore stop */\n      const q0 = q[1]\n      if (!q0) {\n        this.#queues.delete(path)\n        continue\n      }\n      q.shift()\n      if (typeof q0 === 'function') {\n        next.add(q0)\n      } else {\n        for (const f of q0) {\n          next.add(f)\n        }\n      }\n    }\n\n    for (const dir of dirs) {\n      const q = this.#queues.get(dir)\n      const q0 = q?.[0]\n      /* c8 ignore next - type safety only */\n      if (!q || !(q0 instanceof Set)) continue\n      if (q0.size === 1 && q.length === 1) {\n        this.#queues.delete(dir)\n        continue\n      } else if (q0.size === 1) {\n        q.shift()\n        // next one must be a function,\n        // or else the Set would've been reused\n        const n = q[0]\n        if (typeof n === 'function') {\n          next.add(n)\n        }\n      } else {\n        q0.delete(fn)\n      }\n    }\n\n    this.#running.delete(fn)\n    next.forEach(fn => this.#run(fn))\n    return true\n  }\n}\n","// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache: Record<string, string> = Object.create(null)\n\n// Limit the size of this. Very low-sophistication LRU cache\nconst MAX = 10000\nconst cache = new Set<string>()\nexport const normalizeUnicode = (s: string): string => {\n  if (!cache.has(s)) {\n    // shake out identical accents and ligatures\n    normalizeCache[s] = s\n      .normalize('NFD')\n      .toLocaleLowerCase('en')\n      .toLocaleUpperCase('en')\n  } else {\n    cache.delete(s)\n  }\n  cache.add(s)\n\n  const ret = normalizeCache[s] as string\n\n  let i = cache.size - MAX\n  // only prune when we're 10% over the max\n  if (i > MAX / 10) {\n    for (const s of cache) {\n      cache.delete(s)\n      delete normalizeCache[s]\n      if (--i <= 0) break\n    }\n  }\n\n  return ret\n}\n","// separate file so I stop getting nagged in vim about deprecated API.\nexport const umask = () => process.umask()\n","// tar -r\nimport { WriteStream, WriteStreamSync } from '@isaacs/fs-minipass'\nimport { Minipass } from 'minipass'\nimport fs from 'node:fs'\nimport path from 'node:path'\nimport { Header } from './header.js'\nimport { list } from './list.js'\nimport { makeCommand } from './make-command.js'\nimport {\n  isFile,\n  TarOptionsFile,\n  TarOptionsSyncFile,\n} from './options.js'\nimport { Pack, PackSync } from './pack.js'\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst replaceSync = (opt: TarOptionsSyncFile, files: string[]) => {\n  const p = new PackSync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if ((er as NodeJS.ErrnoException)?.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (\n      position = 0;\n      position < st.size;\n      position += 512\n    ) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd,\n          headBuf,\n          bufPos,\n          headBuf.length - bufPos,\n          position + bufPos,\n        )\n\n        if (\n          position === 0 &&\n          headBuf[0] === 0x1f &&\n          headBuf[1] === 0x8b\n        ) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache && h.mtime) {\n        opt.mtimeCache.set(String(h.path), h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd as number)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (\n  opt: TarOptionsSyncFile,\n  p: Pack,\n  position: number,\n  fd: number,\n  files: string[],\n) => {\n  const stream = new WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream as unknown as Minipass.Writable)\n  addFilesSync(p, files)\n}\n\nconst replaceAsync = (\n  opt: TarOptionsFile,\n  files: string[],\n): Promise<void> => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (\n    fd: number,\n    size: number,\n    cb_: (er?: null | Error, pos?: number) => void,\n  ) => {\n    const cb = (er?: Error | null, pos?: number) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er?: null | Error, bytes?: number): void => {\n      if (er || typeof bytes === 'undefined') {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd,\n          headBuf,\n          bufPos,\n          headBuf.length - bufPos,\n          position + bufPos,\n          onread,\n        )\n      }\n\n      if (\n        position === 0 &&\n        headBuf[0] === 0x1f &&\n        headBuf[1] === 0x8b\n      ) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      /* c8 ignore next */\n      const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache && h.mtime) {\n        opt.mtimeCache.set(String(h.path), h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise<void>((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (\n      er?: NodeJS.ErrnoException | null,\n      fd?: number,\n    ) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er || !fd) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream as unknown as Minipass.Writable)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return promise\n}\n\nconst addFilesSync = (p: Pack, files: string[]) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      list({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onReadEntry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = async (\n  p: Pack,\n  files: string[],\n): Promise<void> => {\n  for (let i = 0; i < files.length; i++) {\n    const file = String(files[i])\n    if (file.charAt(0) === '@') {\n      await list({\n        file: path.resolve(String(p.cwd), file.slice(1)),\n        noResume: true,\n        onReadEntry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nexport const replace = makeCommand(\n  replaceSync,\n  replaceAsync,\n  /* c8 ignore start */\n  (): never => {\n    throw new TypeError('file is required')\n  },\n  (): never => {\n    throw new TypeError('file is required')\n  },\n  /* c8 ignore stop */\n  (opt, entries) => {\n    if (!isFile(opt)) {\n      throw new TypeError('file is required')\n    }\n\n    if (\n      opt.gzip ||\n      opt.brotli ||\n      opt.zstd ||\n      opt.file.endsWith('.br') ||\n      opt.file.endsWith('.tbr')\n    ) {\n      throw new TypeError('cannot append to compressed archives')\n    }\n\n    if (!entries?.length) {\n      throw new TypeError('no paths specified to add/replace')\n    }\n  },\n)\n","// tar -u\n\nimport { makeCommand } from './make-command.js'\nimport { type TarOptionsWithAliases } from './options.js'\n\nimport { replace as r } from './replace.js'\n\n// just call tar.r with the filter and mtimeCache\nexport const update = makeCommand(\n  r.syncFile,\n  r.asyncFile,\n  r.syncNoFile,\n  r.asyncNoFile,\n  (opt, entries = []) => {\n    r.validate?.(opt, entries)\n    mtimeFilter(opt)\n  },\n)\n\nconst mtimeFilter = (opt: TarOptionsWithAliases) => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter =\n    filter ?\n      (path, stat) =>\n        filter(path, stat) &&\n        !(\n          /* c8 ignore start */\n          (\n            (opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n            (stat.mtime ?? 0)\n          )\n          /* c8 ignore stop */\n        )\n    : (path, stat) =>\n        !(\n          /* c8 ignore start */\n          (\n            (opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n            (stat.mtime ?? 0)\n          )\n          /* c8 ignore stop */\n        )\n}\n","/// <reference path=\"../References.d.ts\"/>\nimport * as Errors from \"../Errors\"\nimport fs from \"fs\";\nimport * as tar from \"tar\";\nimport childProcess from \"child_process\";\nimport electron from \"electron\";\nimport path from \"path\";\n\nexport function uuid(): string {\n\treturn (+new Date() + Math.floor(Math.random() * 999999)).toString(36);\n}\n\nexport function uuidRand(): string {\n\tlet id = \"\"\n\n\tfor (let i = 0; i < 4; i++) {\n\t\tid += Math.floor((1 + Math.random()) * 0x10000).toString(\n\t\t\t16).substring(1);\n\t}\n\n\treturn id;\n}\n\nexport function nonce(): string {\n\tlet nonce = ''\n\n\tfor (let i = 0; i < 8; i++) {\n\t\tnonce += Math.floor((1 + Math.random()) * 0x10000).toString(\n\t\t\t16).substring(1)\n\t}\n\n\treturn nonce\n}\n\nexport function titleCase(str: string): string {\n\treturn str\n\t\t.toLowerCase()\n\t\t.split(' ')\n\t\t.map(word => word.charAt(0).toUpperCase() + word.slice(1))\n\t\t.join(' ');\n}\n\nexport function shuffle(n: any[]): any[] {\n\tlet i = n.length, j\n\twhile (i != 0) {\n\t\tj = Math.floor(Math.random() * i)\n\t\ti--\n\t\t[n[i], n[j]] = [n[j], n[i]]\n\t}\n\treturn n\n}\n\nexport function objectIdNil(objId: string): boolean {\n\treturn !objId || objId == '000000000000000000000000';\n}\n\nexport function zeroPad(num: number, width: number): string {\n\tif (num < Math.pow(10, width)) {\n\t\treturn ('0'.repeat(width - 1) + num).slice(-width);\n\t}\n\treturn num.toString();\n}\n\nexport function capitalize(str: string): string {\n\treturn str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nexport function formatAmount(amount: number): string {\n\tif (!amount) {\n\t\treturn '-';\n\t}\n\treturn '$' + (amount / 100).toFixed(2);\n}\n\nexport function formatDate(dateData: any): string {\n\tif (!dateData || dateData === '0001-01-01T00:00:00Z') {\n\t\treturn '';\n\t}\n\n\tlet date: Date;\n\tif (dateData instanceof String) {\n\t\tdate = new Date(dateData as string);\n\t} else {\n\t\tdate = new Date(0)\n\t\tdate.setUTCSeconds(dateData as number)\n\t}\n\n\tlet str = '';\n\n\tlet hours = date.getHours();\n\tlet period = 'AM';\n\n\tif (hours > 12) {\n\t\tperiod = 'PM';\n\t\thours -= 12;\n\t} else if (hours === 0) {\n\t\thours = 12;\n\t}\n\n\tlet day;\n\tswitch (date.getDay()) {\n\t\tcase 0:\n\t\t\tday = 'Sun';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tday = 'Mon';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tday = 'Tue';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tday = 'Wed';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tday = 'Thu';\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tday = 'Fri';\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tday = 'Sat';\n\t\t\tbreak;\n\t}\n\n\tlet month;\n\tswitch (date.getMonth()) {\n\t\tcase 0:\n\t\t\tmonth = 'Jan';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmonth = 'Feb';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmonth = 'Mar';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmonth = 'Apr';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmonth = 'May';\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmonth = 'Jun';\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmonth = 'Jul';\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmonth = 'Aug';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmonth = 'Sep';\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmonth = 'Oct';\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmonth = 'Nov';\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tmonth = 'Dec';\n\t\t\tbreak;\n\t}\n\n\tstr += day + ' ';\n\tstr += date.getDate() + ' ';\n\tstr += month + ' ';\n\tstr += date.getFullYear() + ', ';\n\tstr += hours + ':';\n\tstr += zeroPad(date.getMinutes(), 2) + ':';\n\tstr += zeroPad(date.getSeconds(), 2) + ' ';\n\tstr += period;\n\n\treturn str;\n}\n\nexport function formatDateLess(dateData: any): string {\n\tif (!dateData || dateData === '0001-01-01T00:00:00Z') {\n\t\treturn '';\n\t}\n\n\tlet date: Date;\n\tif (dateData instanceof String) {\n\t\tdate = new Date(dateData as string);\n\t} else {\n\t\tdate = new Date(0)\n\t\tdate.setUTCSeconds(dateData as number)\n\t}\n\n\tlet str = '';\n\n\tlet hours = date.getHours();\n\tlet period = 'AM';\n\n\tif (hours > 12) {\n\t\tperiod = 'PM';\n\t\thours -= 12;\n\t} else if (hours === 0) {\n\t\thours = 12;\n\t}\n\n\tlet month;\n\tswitch (date.getMonth()) {\n\t\tcase 0:\n\t\t\tmonth = 'Jan';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmonth = 'Feb';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmonth = 'Mar';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmonth = 'Apr';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmonth = 'May';\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmonth = 'Jun';\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmonth = 'Jul';\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmonth = 'Aug';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmonth = 'Sep';\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmonth = 'Oct';\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmonth = 'Nov';\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tmonth = 'Dec';\n\t\t\tbreak;\n\t}\n\n\tstr += month + ' ';\n\tstr += date.getDate() + ' ';\n\tstr += date.getFullYear() + ', ';\n\tstr += hours + ':';\n\tstr += zeroPad(date.getMinutes(), 2);\n\tstr += period;\n\n\treturn str;\n}\n\nexport function formatDateShort(dateData: any): string {\n\tif (!dateData || dateData === '0001-01-01T00:00:00Z') {\n\t\treturn '';\n\t}\n\n\tlet date: Date\n\tif (dateData instanceof String) {\n\t\tdate = new Date(dateData as string)\n\t} else {\n\t\tdate = new Date(0)\n\t\tdate.setUTCSeconds(dateData as number)\n\t}\n\n\tlet curDate = new Date();\n\n\tlet month;\n\tswitch (date.getMonth()) {\n\t\tcase 0:\n\t\t\tmonth = 'Jan';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmonth = 'Feb';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmonth = 'Mar';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmonth = 'Apr';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmonth = 'May';\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmonth = 'Jun';\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmonth = 'Jul';\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmonth = 'Aug';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmonth = 'Sep';\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmonth = 'Oct';\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmonth = 'Nov';\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tmonth = 'Dec';\n\t\t\tbreak;\n\t}\n\n\tlet str = month + ' ' + date.getDate();\n\n\tif (date.getFullYear() !== curDate.getFullYear()) {\n\t\tstr += ' ' + date.getFullYear();\n\t}\n\n\treturn str;\n}\n\nexport function formatDateShortTime(dateData: any): string {\n\tif (!dateData || dateData === '0001-01-01T00:00:00Z') {\n\t\treturn '';\n\t}\n\n\tlet date: Date\n\tif (dateData instanceof String) {\n\t\tdate = new Date(dateData as string)\n\t} else {\n\t\tdate = new Date(0)\n\t\tdate.setUTCSeconds(dateData as number)\n\t}\n\n\tlet curDate = new Date();\n\n\tlet month;\n\tswitch (date.getMonth()) {\n\t\tcase 0:\n\t\t\tmonth = 'Jan';\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tmonth = 'Feb';\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tmonth = 'Mar';\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tmonth = 'Apr';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmonth = 'May';\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tmonth = 'Jun';\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tmonth = 'Jul';\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmonth = 'Aug';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmonth = 'Sep';\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmonth = 'Oct';\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tmonth = 'Nov';\n\t\t\tbreak;\n\t\tcase 11:\n\t\t\tmonth = 'Dec';\n\t\t\tbreak;\n\t}\n\n\tlet str = month + ' ' + date.getDate();\n\n\tif (date.getFullYear() !== curDate.getFullYear()) {\n\t\tstr += ' ' + date.getFullYear();\n\t} else if (date.getMonth() === curDate.getMonth() &&\n\t\t\tdate.getDate() === curDate.getDate()) {\n\t\tlet hours = date.getHours();\n\t\tlet period = 'AM';\n\n\t\tif (hours > 12) {\n\t\t\tperiod = 'PM';\n\t\t\thours -= 12;\n\t\t} else if (hours === 0) {\n\t\t\thours = 12;\n\t\t}\n\n\t\tstr = hours + ':';\n\t\tstr += zeroPad(date.getMinutes(), 2) + ':';\n\t\tstr += zeroPad(date.getSeconds(), 2) + ' ';\n\t\tstr += period;\n\t}\n\n\treturn str;\n}\n\nexport interface ExecOutput {\n\tstdout: string\n\tstderr: string\n\terror: Errors.ExecError\n}\n\nexport function exec(path: string,\n\t...args: string[]): Promise<ExecOutput> {\n\n\treturn new Promise<ExecOutput>((resolve): void => {\n\t\tchildProcess.execFile(path, args, (err, stdout, stderr) => {\n\t\t\tif (err) {\n\t\t\t\terr = new Errors.ExecError(err, \"Utils: Exec error\",\n\t\t\t\t\t{path: path, args: args, stdout: stdout, stderr: stderr});\n\t\t\t}\n\n\t\t\tresolve({\n\t\t\t\tstdout: stdout,\n\t\t\t\tstderr: stderr,\n\t\t\t\terror: err,\n\t\t\t} as ExecOutput)\n\t\t})\n\t})\n}\n\nexport function fileExists(path: string): Promise<boolean> {\n\treturn new Promise<boolean>((resolve): void => {\n\t\tfs.stat(path, (err: Error, stat) => {\n\t\t\tif (!err) {\n\t\t\t\tresolve(true)\n\t\t\t}\telse {\n\t\t\t\tresolve(false)\n\t\t\t}\n\t\t})\n\t})\n}\n\nexport function fileSize(path: string): Promise<number> {\n\treturn new Promise<number>((resolve): void => {\n\t\tfs.stat(path, (err: Error, stat) => {\n\t\t\tif (err || !stat) {\n\t\t\t\tresolve(0)\n\t\t\t}\n\t\t\tresolve(stat.size || 0)\n\t\t})\n\t})\n}\n\nexport function fileDelete(path: string): Promise<void> {\n\treturn new Promise<void>((resolve, reject): void => {\n\t\tfs.exists(path, (exists: boolean): void => {\n\t\t\tif (!exists) {\n\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfs.unlink(path, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\terr = new Errors.WriteError(err, \"Utils: Failed to delete file\",\n\t\t\t\t\t\t{path: path});\n\t\t\t\t\treject(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresolve()\n\t\t\t})\n\t\t})\n\t})\n}\n\nexport function fileRead(path: string): Promise<string> {\n\treturn new Promise<string>((resolve, reject): void => {\n\t\tfs.readFile(\n\t\t\tpath, \"utf-8\",\n\t\t\t(err: NodeJS.ErrnoException, data: string): void => {\n\t\t\t\tif (err) {\n\t\t\t\t\terr = new Errors.ReadError(err, \"Utils: Failed to read file\",\n\t\t\t\t\t\t{path: path});\n\t\t\t\t\treject(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tresolve(data)\n\t\t\t},\n\t\t)\n\t})\n}\n\nexport function fileWrite(path: string, data: string): Promise<void> {\n\treturn new Promise<void>((resolve, reject): void => {\n\t\tfs.writeFile(\n\t\t\tpath, data,\n\t\t\t(err: NodeJS.ErrnoException): void => {\n\t\t\t\tif (err) {\n\t\t\t\t\terr = new Errors.WriteError(err, \"Utils: Failed to write file\",\n\t\t\t\t\t\t{path: path});\n\t\t\t\t\treject(err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tresolve()\n\t\t\t},\n\t\t)\n\t})\n}\n\nexport function uriFromPath(pth: string): string {\n\tconst pathName = path.resolve(pth).replace(/\\\\/g, \"/\")\n\treturn encodeURI(\"file://\" + (pathName.charAt(0) !== \"/\" ?\n\t\t\"/\" + pathName : pathName))\n}\n\nexport function encryptAvailable(): Promise<boolean> {\n\treturn new Promise<boolean>((resolve, reject): void => {\n\t\ttry {\n\t\t\tlet evt = electron.ipcRenderer.invoke(\"processing\", \"encryptable\")\n\n\t\t\tevt.then((resp: [Error, boolean]) => {\n\t\t\t\tif (!resp) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tnull, \"Utils: Failed to check encryption support e1\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else if (resp[0]) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tresp[0], \"Utils: Failed to check encryption support e2\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(resp[1])\n\t\t\t\t}\n\t\t\t}).catch((err) => {\n\t\t\t\terr = new Errors.ParseError(\n\t\t\t\t\terr, \"Utils: Failed to check encryption support e3\");\n\t\t\t\treject(err)\n\t\t\t})\n\t\t} catch (err) {\n\t\t\terr = new Errors.ParseError(\n\t\t\t\terr, \"Utils: Failed to check encryption support e4\");\n\t\t\treject(err)\n\t\t}\n\t})\n}\n\nexport function encryptString(decData: string): Promise<string> {\n\treturn new Promise<string>((resolve, reject): void => {\n\t\ttry {\n\t\t\tlet evt = electron.ipcRenderer.invoke(\"processing\", \"encrypt\", decData)\n\n\t\t\tevt.then((resp: [Error, string]) => {\n\t\t\t\tif (!resp) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tnull, \"Utils: Failed to encrypt string e1\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else if (resp[0]) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tresp[0], \"Utils: Failed to encrypt string e2\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(resp[1])\n\t\t\t\t}\n\t\t\t}).catch((err) => {\n\t\t\t\terr = new Errors.ParseError(\n\t\t\t\t\terr, \"Utils: Failed to encrypt string e3\");\n\t\t\t\treject(err)\n\t\t\t})\n\t\t} catch (err) {\n\t\t\terr = new Errors.ParseError(\n\t\t\t\terr, \"Utils: Failed to encrypt string e4\");\n\t\t\treject(err)\n\t\t}\n\t})\n}\n\nexport function decryptString(encData: string): Promise<string> {\n\treturn new Promise<string>((resolve, reject): void => {\n\t\ttry {\n\t\t\tlet evt = electron.ipcRenderer.invoke(\"processing\", \"decrypt\", encData)\n\n\t\t\tevt.then((resp: [Error, string]) => {\n\t\t\t\tif (!resp) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tnull, \"Utils: Failed to decrypt string e1\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else if (resp[0]) {\n\t\t\t\t\tlet err = new Errors.ParseError(\n\t\t\t\t\t\tresp[0], \"Utils: Failed to decrypt string e2\");\n\t\t\t\t\treject(err)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(resp[1])\n\t\t\t\t}\n\t\t\t}).catch((err) => {\n\t\t\t\terr = new Errors.ParseError(\n\t\t\t\t\terr, \"Utils: Failed to decrypt string e3\");\n\t\t\t\treject(err)\n\t\t\t})\n\t\t} catch (err) {\n\t\t\terr = new Errors.ParseError(\n\t\t\t\terr, \"Utils: Failed to decrypt string e4\");\n\t\t\treject(err)\n\t\t}\n\t})\n}\n\nexport interface TarData {\n\tpath: string\n\tdata: string\n}\n\nexport function tarRead(pth: string): Promise<TarData[]> {\n\tlet files: TarData[] = []\n\n\treturn tar.list({\n\t\tfile: pth,\n\t\tonReadEntry: (entry: tar.ReadEntry) => {\n\t\t\tlet data = \"\"\n\n\t\t\tentry.on(\"data\", (content: Buffer) => {\n\t\t\t\tdata += content.toString()\n\t\t\t})\n\t\t\tentry.on(\"end\", () => {\n\t\t\t\tfiles.push({\n\t\t\t\t\tpath: entry.path,\n\t\t\t\t\tdata: data,\n\t\t\t\t})\n\t\t\t})\n\t\t},\n\t}).then(() => {\n\t\treturn files\n\t}).catch((err) => {\n\t\tthrow new Errors.ReadError(err, \"Utils: Failed to read tar file\",\n\t\t\t{path: pth})\n\t})\n}\n","import WebSocket from \"ws\"\nimport process from \"process\"\nimport * as Request from \"./Request\"\nimport * as RequestUtils from './RequestUtils';\nimport * as Auth from \"./Auth\"\nimport * as Logger from \"./Logger\"\nimport * as Constants from \"./Constants\"\nimport electron from \"electron\";\nimport * as MiscUtils from \"../app/utils/MiscUtils\";\n\nexport interface Event {\n\tid: string\n\ttype: string\n\tdata?: any\n}\n\nexport type Callback = (event: Event) => void\n\nlet showConnect = false\nlet socket: WebSocket.WebSocket\nlet callbacks: Callback[] = []\n\nexport let winDrive = 'C:\\\\';\nlet systemDrv = process.env.SYSTEMDRIVE;\nif (systemDrv) {\n\twinDrive = systemDrv + '\\\\';\n}\n\nexport function sync(): Promise<boolean> {\n\treturn new Promise<boolean>(async (resolve) => {\n\t\ttry {\n\t\t\tawait Auth.load()\n\t\t} catch(err) {\n\t\t\tLogger.error(err)\n\t\t\tresolve(false)\n\t\t\treturn\n\t\t}\n\n\t\tRequestUtils\n\t\t\t.get(\"/status\")\n\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t.end()\n\t\t\t.then((resp: Request.Response) => {\n\t\t\t\tif (resp.status === 200) {\n\t\t\t\t\tlet data = resp.jsonPassive() as any\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\tresolve(data.status)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(false)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresolve(false)\n\t\t\t\t}\n\t\t\t}, (err) => {\n\t\t\t\tLogger.error(err)\n\t\t\t\tresolve(false)\n\t\t\t})\n\t})\n}\n\nexport function wakeup(): Promise<boolean> {\n\treturn new Promise<boolean>(async (resolve) => {\n\t\ttry {\n\t\t\tawait Auth.load()\n\t\t} catch(err) {\n\t\t\tLogger.error(err)\n\t\t\tresolve(false)\n\t\t\treturn\n\t\t}\n\n\t\tRequestUtils\n\t\t\t.post(\"/wakeup\")\n\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t.end()\n\t\t\t.then((resp: Request.Response) => {\n\t\t\t\tif (resp.status === 200) {\n\t\t\t\t\tresolve(true)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(false)\n\t\t\t\t}\n\t\t\t}, (err) => {\n\t\t\t\tLogger.error(err)\n\t\t\t\tresolve(false)\n\t\t\t})\n\t})\n}\n\nexport function cleanup(): Promise<boolean> {\n\treturn new Promise<boolean>(async (resolve) => {\n\t\ttry {\n\t\t\tawait Auth.load()\n\t\t} catch(err) {\n\t\t\tLogger.error(err)\n\t\t\tresolve(false)\n\t\t\treturn\n\t\t}\n\n\t\tRequestUtils\n\t\t\t.post(\"/cleanup\")\n\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t.end()\n\t\t\t.then((resp: Request.Response) => {\n\t\t\t\tif (resp.status === 200) {\n\t\t\t\t\tresolve(true)\n\t\t\t\t} else {\n\t\t\t\t\tresolve(false)\n\t\t\t\t}\n\t\t\t}, (err) => {\n\t\t\t\tLogger.error(err)\n\t\t\t\tresolve(false)\n\t\t\t})\n\t})\n}\n\nlet authAttempts = 0\nlet connAttempts = 0\nlet dialogShown = false\nlet curSocket = \"\"\n\nexport function connect(): Promise<void> {\n\tlet socketId = MiscUtils.uuid()\n\tcurSocket = socketId\n\n\treturn new Promise<void>(async (resolve, reject) => {\n\t\ttry {\n\t\t\tawait Auth.load()\n\t\t} catch(err) {\n\t\t}\n\n\t\tif (!Auth.token) {\n\t\t\tif (authAttempts > 20) {\n\t\t\t\tif (!dialogShown) {\n\t\t\t\t\tdialogShown = true\n\t\t\t\t\telectron.dialog.showMessageBox(null, {\n\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\tbuttons: [\"Retry\", \"Exit\"],\n\t\t\t\t\t\ttitle: \"Pritunl - Service Error (6729\",\n\t\t\t\t\t\tmessage: \"Unable to authenticate communication with \" +\n\t\t\t\t\t\t\t\"background service, try restarting computer\",\n\t\t\t\t\t}).then(function(evt) {\n\t\t\t\t\t\tif (evt.response == 0) {\n\t\t\t\t\t\t\tauthAttempts = 0\n\t\t\t\t\t\t\tconnAttempts = 0\n\t\t\t\t\t\t\tdialogShown = false\n\t\t\t\t\t\t\tconnect()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telectron.app.quit()\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tauthAttempts += 1\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tconnect()\n\t\t\t\t}, 500)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tresolve()\n\n\t\tlet reconnected = false\n\t\tlet wsHost = \"\"\n\t\tlet headers = {\n\t\t\t\"User-Agent\": \"pritunl\",\n\t\t\t\"Auth-Token\": Auth.token,\n\t\t} as any\n\n\t\tif (Constants.unix) {\n\t\t\twsHost = Constants.unixWsHost\n\t\t\theaders[\"Host\"] = \"unix\"\n\t\t} else {\n\t\t\twsHost = Constants.webWsHost\n\t\t}\n\n\t\tlet reconnect = (): void => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (reconnected) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treconnected = true\n\n\t\t\t\tif (connAttempts > 30) {\n\t\t\t\t\tif (!dialogShown) {\n\t\t\t\t\t\tdialogShown = true\n\t\t\t\t\t\telectron.dialog.showMessageBox(null, {\n\t\t\t\t\t\t\ttype: \"error\",\n\t\t\t\t\t\t\tbuttons: [\"Retry\", \"Exit\"],\n\t\t\t\t\t\t\ttitle: \"Pritunl - Service Error (8362)\",\n\t\t\t\t\t\t\tmessage: \"Unable to establish communication with \" +\n\t\t\t\t\t\t\t\t\"background service, try restarting computer\",\n\t\t\t\t\t\t}).then(function (evt) {\n\t\t\t\t\t\t\tif (evt.response == 0) {\n\t\t\t\t\t\t\t\tauthAttempts = 0\n\t\t\t\t\t\t\t\tconnAttempts = 0\n\t\t\t\t\t\t\t\tdialogShown = false\n\t\t\t\t\t\t\t\tconnect()\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telectron.app.quit()\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconnAttempts += 1\n\t\t\t\t}\n\t\t\t\tconnect()\n\t\t\t}, 1000)\n\t\t}\n\n\t\tsocket = new WebSocket(wsHost + \"/events\", {\n\t\t\theaders: headers,\n\t\t})\n\n\t\tsocket.on(\"open\", (): void => {\n\t\t\tif (socketId !== curSocket) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconnAttempts = 0\n\t\t\tif (showConnect) {\n\t\t\t\tshowConnect = false\n\t\t\t\tconsole.log(\"Events: Service reconnected\")\n\t\t\t\tif (Constants.mainWindow && !Constants.mainWindow.isDestroyed()) {\n\t\t\t\t\tConstants.mainWindow.webContents.send(\"event.reconnected\")\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\n\t\tsocket.on(\"error\", (err: Error) => {\n\t\t\tif (socketId !== curSocket) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (Constants.mainWindow && !Constants.mainWindow.isDestroyed()) {\n\t\t\t\tConstants.mainWindow.webContents.send(\"event.error\", err.toString())\n\t\t\t}\n\n\t\t\tconsole.error(\"Events: Socket error \" + err)\n\t\t\tshowConnect = true\n\t\t\treconnect()\n\t\t})\n\n\t\tsocket.on(\"onerror\", (err) => {\n\t\t\tif (socketId !== curSocket) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconsole.error(\"Events: Socket error \" + err)\n\t\t\tshowConnect = true\n\t\t\treconnect()\n\t\t})\n\n\t\tsocket.on(\"close\", () => {\n\t\t\tif (socketId !== curSocket) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (Constants.mainWindow && !Constants.mainWindow.isDestroyed()) {\n\t\t\t\tConstants.mainWindow.webContents.send(\"event.closed\")\n\t\t\t}\n\n\t\t\tshowConnect = true\n\t\t\treconnect()\n\t\t})\n\n\t\tsocket.on(\"message\", (dataBuf: Buffer): void => {\n\t\t\tif (socketId !== curSocket) {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tlet dataStr = dataBuf.toString()\n\n\t\t\tif (Constants.mainWindow && !Constants.mainWindow.isDestroyed()) {\n\t\t\t\tConstants.mainWindow.webContents.send(\"event\", dataStr)\n\t\t\t}\n\n\t\t\tlet data = JSON.parse(dataStr)\n\t\t\tfor (let callback of callbacks) {\n\t\t\t\tcallback(data as Event)\n\t\t\t}\n\t\t})\n\t})\n}\n\nexport function send(msg: string) {\n\tif (socket) {\n\t\tsocket.send(msg)\n\t}\n}\n\nexport function subscribe(callback: Callback) {\n\tcallbacks.push(callback)\n}\n","import fs from \"fs\"\nimport path from \"path\"\nimport electron from \"electron\"\nimport * as Errors from \"./Errors\"\nimport * as Logger from \"./Logger\"\n\nclass ConfigData {\n\twindow_width = 0\n\twindow_height = 0\n\tdisable_tray_icon = false\n\tclassic_interface = false\n\tframeless: boolean = null\n\ttheme = \"dark\"\n\n\t_load(data: {[key: string]: any}): void {\n\t\tif (data[\"disable_tray_icon\"] !== undefined) {\n\t\t\tthis.disable_tray_icon = data[\"disable_tray_icon\"]\n\t\t}\n\t\tif (data[\"classic_interface\"] !== undefined) {\n\t\t\tthis.classic_interface = data[\"classic_interface\"]\n\t\t}\n\t\tif (data[\"theme\"] !== undefined) {\n\t\t\tthis.theme = data[\"theme\"]\n\t\t}\n\t\tif (data[\"window_width\"] !== undefined) {\n\t\t\tthis.window_width = data[\"window_width\"]\n\t\t}\n\t\tif (data[\"window_height\"] !== undefined) {\n\t\t\tthis.window_height = data[\"window_height\"]\n\t\t}\n\t\tif (data[\"frameless\"] !== undefined) {\n\t\t\tthis.frameless = data[\"frameless\"]\n\t\t}\n\t}\n\n\tpath(): string {\n\t\treturn path.join(electron.app.getPath(\"userData\"), \"pritunl.json\")\n\t}\n\n\tload(): Promise<void> {\n\t\treturn new Promise<void>((resolve): void => {\n\t\t\tfs.readFile(\n\t\t\t\tthis.path(), \"utf-8\",\n\t\t\t\t(err: NodeJS.ErrnoException, data: string): void => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\terr = new Errors.ReadError(err, \"Config: Read error\")\n\t\t\t\t\t\t\tLogger.error(err)\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tlet configData: any = {}\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconfigData = JSON.parse(data)\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\terr = new Errors.ReadError(err, \"Config: Parse error\")\n\t\t\t\t\t\t\tLogger.error(err)\n\n\t\t\t\t\t\t\tconfigData = {}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._load(configData)\n\n\t\t\t\t\tresolve()\n\t\t\t\t},\n\t\t\t)\n\t\t})\n\t}\n\n\tsave(opts: {[key: string]: any}): Promise<void> {\n\t\tlet data = {\n\t\t\tdisable_tray_icon: opts[\"disable_tray_icon\"],\n\t\t\tclassic_interface: opts[\"classic_interface\"],\n\t\t\twindow_width: opts[\"window_width\"],\n\t\t\twindow_height: opts[\"window_height\"],\n\t\t\tframeless: opts[\"frameless\"],\n\t\t\ttheme: opts[\"theme\"],\n\t\t}\n\n\t\treturn new Promise<void>((resolve, reject): void => {\n\t\t\tthis.load().then((): void => {\n\t\t\t\tif (data.disable_tray_icon === undefined) {\n\t\t\t\t\tdata.disable_tray_icon = this.disable_tray_icon\n\t\t\t\t}\n\t\t\t\tif (data.classic_interface === undefined) {\n\t\t\t\t\tdata.classic_interface = this.classic_interface\n\t\t\t\t}\n\t\t\t\tif (data.window_width === undefined) {\n\t\t\t\t\tdata.window_width = this.window_width\n\t\t\t\t}\n\t\t\t\tif (data.theme === undefined) {\n\t\t\t\t\tdata.theme = this.theme\n\t\t\t\t}\n\t\t\t\tif (data.frameless === undefined) {\n\t\t\t\t\tdata.frameless = this.frameless\n\t\t\t\t}\n\n\t\t\t\tthis._load(data)\n\n\t\t\t\tfs.writeFile(\n\t\t\t\t\tthis.path(), JSON.stringify(data),\n\t\t\t\t\t(err: NodeJS.ErrnoException): void => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\terr = new Errors.ReadError(err, \"Config: Write error\")\n\t\t\t\t\t\t\tLogger.error(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresolve()\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n}\n\nconst Config = new ConfigData()\nexport default Config\n","import path from \"path\"\nimport childprocess from \"child_process\"\nimport * as Logger from \"./Logger\"\nimport * as Errors from \"./Errors\"\nimport * as Request from \"./Request\"\nimport * as RequestUtils from './RequestUtils'\nimport * as Auth from \"./Auth\"\nimport process from \"process\";\n\nlet deviceAuthPath = path.join(\"/\", \"Applications\", \"Pritunl.app\",\n\t\"Contents\", \"Resources\", \"Pritunl Device Authentication\")\nif (process.argv.indexOf(\"--dev\") !== -1) {\n\tdeviceAuthPath = path.join(__dirname, \"..\", \"..\", \"..\",\n\t\t\"service_macos\", \"Pritunl Device Authentication\");\n}\n\nlet procs: {[key: string]: childprocess.ChildProcess} = {}\n\nexport function open(callerId: string, privKey64: string): void {\n\tlet proc = childprocess.execFile(deviceAuthPath)\n\tlet stderr = \"\"\n\n\tsetTimeout(() => {\n\t\tif (proc.exitCode === null) {\n\t\t\tlet err = new Errors.ProcessError(\n\t\t\t\tnull,\n\t\t\t\t\"Tpm: Secure enclave process timed out\",\n\t\t\t\t{\n\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t},\n\t\t\t)\n\t\t\tLogger.error(err)\n\t\t}\n\t\tproc.kill(\"SIGINT\")\n\t}, 10000)\n\n\tproc.on(\"error\", (err) => {\n\t\terr = new Errors.ProcessError(\n\t\t\terr,\n\t\t\t\"Tpm: Secure enclave exec error\",\n\t\t\t{\n\t\t\t\tcaller_id: callerId,\n\t\t\t},\n\t\t)\n\t\tLogger.error(err)\n\n\t\tRequestUtils\n\t\t\t.post(\"/tpm/callback\")\n\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t.send({\n\t\t\t\tid: callerId,\n\t\t\t\terror: err.message,\n\t\t\t})\n\t\t\t.end()\n\t\t\t.then((resp: Request.Response) => {\n\t\t\t\tif (resp.status != 200) {\n\t\t\t\t\terr = new Errors.RequestError(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t\t\treponse_status: resp.status,\n\t\t\t\t\t\t\tdata: resp.data,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\tLogger.error(err)\n\t\t\t\t}\n\t\t\t}, (err) => {\n\t\t\t\terr = new Errors.RequestError(\n\t\t\t\t\terr,\n\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\tLogger.error(err)\n\t\t\t})\n\t})\n\n\tproc.on(\"exit\", (code: number, signal: string) => {\n\t\tdelete procs[callerId]\n\n\t\tif (code !== 0) {\n\t\t\tlet err = new Errors.ProcessError(\n\t\t\t\tnull,\n\t\t\t\t\"Tpm: Secure enclave exec code error\",\n\t\t\t\t{\n\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\texit_code: code,\n\t\t\t\t\toutput: stderr,\n\t\t\t\t},\n\t\t\t)\n\t\t\tLogger.error(err)\n\n\t\t\tRequestUtils\n\t\t\t\t.post(\"/tpm/callback\")\n\t\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t\t.send({\n\t\t\t\t\tid: callerId,\n\t\t\t\t\terror: err.message,\n\t\t\t\t})\n\t\t\t\t.end()\n\t\t\t\t.then((resp: Request.Response) => {\n\t\t\t\t\tif (resp.status != 200) {\n\t\t\t\t\t\terr = new Errors.RequestError(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t\t\t\treponse_status: resp.status,\n\t\t\t\t\t\t\t\tdata: resp.data,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t)\n\t\t\t\t\t\tLogger.error(err)\n\t\t\t\t\t}\n\t\t\t\t}, (err) => {\n\t\t\t\t\terr = new Errors.RequestError(\n\t\t\t\t\t\terr,\n\t\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\tLogger.error(err)\n\t\t\t\t})\n\t\t}\n\t})\n\n\tlet outBuffer = \"\"\n\tproc.stdout.on(\"data\", (data) => {\n\t\toutBuffer += data\n\t\tif (!outBuffer.includes(\"\\n\")) {\n\t\t\treturn\n\t\t}\n\t\tlet lines = outBuffer.split(\"\\n\")\n\t\tlet line = lines[0]\n\t\toutBuffer = lines.slice(1).join(\"\\n\")\n\n\t\tlet dataObj: {[key: string]: any}\n\t\ttry {\n\t\t\tdataObj = JSON.parse(line.replace(/\\s/g, \"\"))\n\t\t} catch {\n\t\t\tlet err = new Errors.RequestError(\n\t\t\t\tnull,\n\t\t\t\t\"Tpm: Failed to parse line\",\n\t\t\t\t{\n\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\tline: data,\n\t\t\t\t},\n\t\t\t)\n\t\t\tLogger.error(err)\n\t\t\treturn\n\t\t}\n\n\t\tRequestUtils\n\t\t\t.post(\"/tpm/callback\")\n\t\t\t.set(\"Auth-Token\", Auth.token)\n\t\t\t.set(\"User-Agent\", \"pritunl\")\n\t\t\t.send({\n\t\t\t\tid: callerId,\n\t\t\t\tpublic_key: dataObj.public_key,\n\t\t\t\tprivate_key: dataObj.key_data,\n\t\t\t\tsignature: dataObj.signature,\n\t\t\t})\n\t\t\t.end()\n\t\t\t.then((resp: Request.Response) => {\n\t\t\t\tif (resp.status != 200) {\n\t\t\t\t\tlet err = new Errors.RequestError(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t\t\treponse_status: resp.status,\n\t\t\t\t\t\t\tdata: resp.data,\n\t\t\t\t\t\t},\n\t\t\t\t\t)\n\t\t\t\t\tLogger.error(err)\n\t\t\t\t}\n\t\t\t}, (err) => {\n\t\t\t\terr = new Errors.RequestError(\n\t\t\t\t\terr,\n\t\t\t\t\t\"Tpm: Callback request error\",\n\t\t\t\t\t{\n\t\t\t\t\t\tcaller_id: callerId,\n\t\t\t\t\t},\n\t\t\t\t)\n\t\t\t\tLogger.error(err)\n\t\t\t})\n\t})\n\n\tproc.stderr.on(\"data\", (data) => {\n\t\tstderr += data\n\t})\n\n\tproc.stdin.write(JSON.stringify({\n\t\t\"key_data\": privKey64,\n\t}) + \"\\n\")\n\n\tprocs[callerId] = proc\n}\n\nexport function sign(callerId: string, signData: string): void {\n\tlet proc = procs[callerId]\n\tif (!proc) {\n\t\treturn\n\t}\n\n\tproc.stdin.write(JSON.stringify({\n\t\t\"sign_data\": signData,\n\t}) + \"\\n\")\n}\n\nexport function close(callerId: string): void {\n\tlet proc = procs[callerId]\n\tif (!proc) {\n\t\treturn\n\t}\n\n\tproc.kill(\"SIGINT\")\n}\n","import process from \"process\"\nimport path from \"path\"\nimport fs from \"fs\"\nimport electron from \"electron\"\nimport * as Utils from \"./Utils\";\nimport * as Service from \"./Service\"\nimport * as Constants from \"./Constants\"\nimport Config from \"./Config\"\nimport * as Errors from \"../app/Errors\";\nimport * as Tpm from \"./Tpm\"\n\nlet tray: electron.Tray\nlet awaken: boolean\nlet ready: boolean\nlet readyError: string\nlet main: Main\nlet windowSize: number[];\n\nif (electron.app.dock) {\n\telectron.app.dock.hide()\n}\n\nprocess.on(\"uncaughtException\", function (error) {\n\tlet errorMsg: string\n\tif (error && error.stack) {\n\t\terrorMsg = error.stack\n\t} else {\n\t\terrorMsg = String(error)\n\t}\n\n\tif (!ready) {\n\t\treadyError = errorMsg\n\t\treturn\n\t}\n\n\telectron.dialog.showMessageBox(null, {\n\t\ttype: \"error\",\n\t\tbuttons: [\"Exit\"],\n\t\ttitle: \"Pritunl Client - Process Error\",\n\t\tmessage: \"Error occured in main process:\\n\\n\" + errorMsg,\n\t}).then(function() {\n\t\telectron.app.quit()\n\t})\n})\n\nprocess.on(\"unhandledRejection\", function (error) {\n\tlet errorMsg: string = String(error)\n\n\tif (!ready) {\n\t\treadyError = errorMsg\n\t\treturn\n\t}\n\n\telectron.dialog.showMessageBox(null, {\n\t\ttype: \"error\",\n\t\tbuttons: [\"Exit\"],\n\t\ttitle: \"Pritunl Client - Process Error\",\n\t\tmessage: \"Error occured in main process:\\n\\n\" + errorMsg,\n\t}).then(function() {\n\t\telectron.app.quit()\n\t})\n})\n\nelectron.ipcMain.handle(\n\t\"processing\",\n\t(evt: electron.IpcMainEvent, msg: string, data: string) => {\n\t\tif (msg === \"encrypt\") {\n\t\t\tlet encData = electron.safeStorage.encryptString(\n\t\t\t\tdata).toString(\"base64\")\n\t\t\treturn [null, encData]\n\t\t} else if (msg === \"decrypt\") {\n\t\t\tlet encData = new Buffer(data, \"base64\")\n\t\t\tlet decData = electron.safeStorage.decryptString(\n\t\t\t\tencData)\n\t\t\treturn [null, decData]\n\t\t} else if (msg === \"encryptable\") {\n\t\t\treturn [null, electron.safeStorage.isEncryptionAvailable()]\n\t\t}\n\t\tlet err = new Errors.ParseError(null, \"Main: Unknown handler type\");\n\t\treturn [err, null]\n\t},\n)\n\nelectron.ipcMain.on(\n\t\"control\",\n\t(evt: electron.IpcMainEvent, msg: string, data: string) => {\n\t\tif (msg === \"service-auth-error\") {\n\t\t\telectron.dialog.showMessageBox(null, {\n\t\t\t\ttype: \"error\",\n\t\t\t\tbuttons: [\"Exit\"],\n\t\t\t\ttitle: \"Pritunl - Service Error (4827)\",\n\t\t\t\tmessage: \"Failed to load service key. Restart \" +\n\t\t\t\t\t\"computer and verify background service is running\",\n\t\t\t}).then(function() {\n\t\t\t\telectron.app.quit()\n\t\t\t})\n\t\t} else if (msg === \"service-conn-error\") {\n\t\t\telectron.dialog.showMessageBox(null, {\n\t\t\t\ttype: \"error\",\n\t\t\t\tbuttons: [\"Exit\"],\n\t\t\t\ttitle: \"Pritunl - Service Error (2754)\",\n\t\t\t\tmessage: \"Unable to establish communication with \" +\n\t\t\t\t\t\"background service, try restarting computer\",\n\t\t\t}).then(function() {\n\t\t\t\telectron.app.quit()\n\t\t\t})\n\t\t} else if (msg === \"dev-tools\") {\n\t\t\tif (main && main.window) {\n\t\t\t\tmain.window.webContents.openDevTools({\n\t\t\t\t\t\"mode\": \"undocked\",\n\t\t\t\t})\n\t\t\t}\n\t\t} else if (msg === \"reload\") {\n\t\t\tif (main && main.window) {\n\t\t\t\tmain.window.reload()\n\t\t\t}\n\t\t} else if (msg === \"minimize\") {\n\t\t\tif (main && main.window) {\n\t\t\t\tmain.window.minimize()\n\t\t\t}\n\t\t} else if (msg === \"download-update\") {\n\t\t\tUtils.openLink(\"https://client.pritunl.com/#install\")\n\t\t}\n\t},\n)\n\nService.wakeup().then((awake: boolean) => {\n\tawaken = awake\n\tif (ready) {\n\t\tinit()\n\t}\n})\n\nclass Main {\n\twindow: electron.BrowserWindow\n\n\tshowWindow(): void {\n\t\tthis.window.show()\n\t}\n\n\tcreateWindow(): void {\n\t\tlet frameless = false\n\t\tlet titleBarStyle: string\n\t\tlet framelessClient = false\n\t\tlet width = 424\n\t\tlet height = 528\n\t\tlet minWidth = 385\n\t\tlet minHeight = 440\n\t\tlet maxWidth = 670\n\t\tlet maxHeight = 800\n\n\t\tif (process.platform === \"win32\" || Config.frameless) {\n\t\t\tframeless = true\n\t\t\tframelessClient = true\n\t\t\twidth = 430\n\t\t\tminWidth = 410\n\n\t\t\tif (process.platform === \"win32\") {\n\t\t\t\tframeless = false\n\t\t\t\ttitleBarStyle = \"hidden\"\n\t\t\t}\n\t\t}\n\n\t\tif (Config.window_width && Config.window_height) {\n\t\t\twidth = Config.window_width\n\t\t\tif (width < minWidth) {\n\t\t\t\twidth = minWidth\n\t\t\t}\n\t\t\theight = Config.window_height\n\t\t\tif (height < minHeight) {\n\t\t\t\theight = minHeight\n\t\t\t}\n\t\t}\n\n\t\tlet zoomFactor = 1\n\t\tif (zoomFactor !== 1) {\n\t\t\twidth = Math.round(width * zoomFactor)\n\t\t\theight = Math.round(height * zoomFactor)\n\t\t\tminWidth = Math.round(minWidth * zoomFactor)\n\t\t\tminHeight = Math.round(minHeight * zoomFactor)\n\t\t\tmaxWidth = Math.round(maxWidth * zoomFactor)\n\t\t\tmaxHeight = Math.round(maxHeight * zoomFactor)\n\t\t}\n\n\t\tthis.window = new electron.BrowserWindow({\n\t\t\ttitle: \"Pritunl Client\",\n\t\t\ticon: path.join(__dirname, \"..\", \"logo.png\"),\n\t\t\ttitleBarStyle: titleBarStyle as any,\n\t\t\tframe: !frameless,\n\t\t\tautoHideMenuBar: true,\n\t\t\tfullscreen: false,\n\t\t\tshow: false,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tminWidth: minWidth,\n\t\t\tminHeight: minHeight,\n\t\t\tmaxWidth: maxWidth,\n\t\t\tmaxHeight: maxHeight,\n\t\t\tbackgroundColor: \"#151719\",\n\t\t\twebPreferences: {\n\t\t\t\tzoomFactor: zoomFactor,\n\t\t\t\tdevTools: true,\n\t\t\t\tnodeIntegration: true,\n\t\t\t\tcontextIsolation: false,\n\t\t\t}\n\t\t})\n\n\t\tthis.window.webContents.on(\"context-menu\", (\n\t\t\t\tevt: electron.Event, params: electron.ContextMenuParams) => {\n\n\t\t\tif (params.isEditable) {\n\t\t\t\telectron.Menu.buildFromTemplate([\n\t\t\t\t\t{role: \"undo\"},\n\t\t\t\t\t{role: \"redo\"},\n\t\t\t\t\t{role: \"cut\"},\n\t\t\t\t\t{role: \"copy\"},\n\t\t\t\t\t{role: \"paste\"},\n\t\t\t\t\t{role: \"selectAll\"},\n\t\t\t\t]).popup()\n\t\t\t}\n\t\t})\n\n\t\tConstants.setMainWindow(this.window)\n\n\t\tthis.window.webContents.setUserAgent(\"pritunl\")\n\n\t\tthis.window.on(\"close\", (): void => {\n\t\t\ttry {\n\t\t\t\twindowSize = this.window.getSize()\n\t\t\t} catch {}\n\t\t})\n\n\t\tthis.window.on(\"closed\", async (): Promise<void> => {\n\t\t\tmain = null\n\t\t})\n\n\t\tlet shown = false\n\t\tthis.window.on(\"ready-to-show\", (): void => {\n\t\t\tif (shown) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tshown = true\n\t\t\tthis.window.show()\n\n\t\t\tif (Constants.devTools) {\n\t\t\t\tthis.window.webContents.openDevTools({\n\t\t\t\t\t\"mode\": \"undocked\",\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\tsetTimeout((): void => {\n\t\t\tif (shown) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tshown = true\n\t\t\tthis.window.show()\n\n\t\t\tif (Constants.devTools) {\n\t\t\t\tthis.window.webContents.openDevTools({\n\t\t\t\t\t\"mode\": \"undocked\",\n\t\t\t\t})\n\t\t\t}\n\t\t}, 800)\n\n\t\tlet indexUrl = \"file://\" + path.join(__dirname, \"..\", \"index.html\")\n\t\tindexUrl += \"?dev=\" + (!Constants.production ? \"true\" : \"false\")\n\t\tindexUrl += \"&dataPath=\" + encodeURIComponent(\n\t\t\telectron.app.getPath(\"userData\"))\n\t\tindexUrl += \"&frameless=\" + (framelessClient ? \"true\" : \"false\")\n\n\t\tthis.window.loadURL(indexUrl, {\n\t\t\tuserAgent: \"pritunl\",\n\t\t})\n\n\t\tif (electron.app.dock) {\n\t\t\telectron.app.dock.show()\n\t\t}\n\t}\n\n\trun(): void {\n\t\tif (main) {\n\t\t\tmain.showWindow()\n\t\t\treturn\n\t\t}\n\n\t\tthis.createWindow()\n\t\tmain = this\n\t}\n}\n\nfunction initTray() {\n\ttray = new electron.Tray(getTrayIcon(false))\n\n\ttray.on(\"click\", function() {\n\t\tlet main = new Main()\n\t\tmain.run()\n\t})\n\ttray.on(\"double-click\", function() {\n\t\tlet main = new Main()\n\t\tmain.run()\n\t})\n\n\tlet trayMenu = electron.Menu.buildFromTemplate([\n\t\t{\n\t\t\tlabel: \"Open Pritunl Client\",\n\t\t\tclick: function () {\n\t\t\t\tlet main = new Main()\n\t\t\t\tmain.run()\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\tlabel: \"Exit\",\n\t\t\tclick: function() {\n\t\t\t\telectron.app.quit()\n\t\t\t}\n\t\t}\n\t])\n\n\ttray.setToolTip(\"Pritunl Client\")\n\ttray.setContextMenu(trayMenu)\n\n\tService.sync().then((status: boolean): void => {\n\t\tif (tray) {\n\t\t\ttray.setImage(getTrayIcon(status))\n\t\t}\n\t})\n}\n\nfunction initAppMenu() {\n\tlet appMenu = electron.Menu.buildFromTemplate([\n\t\t{\n\t\t\tlabel: \"Pritunl\",\n\t\t\tsubmenu: [\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Pritunl Client\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Close\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+W\",\n\t\t\t\t\trole: \"close\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Exit\",\n\t\t\t\t\taccelerator: \"Cmd+Q\",\n\t\t\t\t\tclick: function() {\n\t\t\t\t\t\telectron.app.quit()\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\t{\n\t\t\tlabel: \"Edit\",\n\t\t\tsubmenu: [\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Undo\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+Z\",\n\t\t\t\t\trole: \"undo\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Redo\",\n\t\t\t\t\taccelerator: \"Shift+CmdOrCtrl+Z\",\n\t\t\t\t\trole: \"redo\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: \"separator\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Cut\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+X\",\n\t\t\t\t\trole: \"cut\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Copy\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+C\",\n\t\t\t\t\trole: \"copy\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Paste\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+V\",\n\t\t\t\t\trole: \"paste\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tlabel: \"Select All\",\n\t\t\t\t\taccelerator: \"CmdOrCtrl+A\",\n\t\t\t\t\trole: \"selectall\",\n\t\t\t\t},\n\t\t\t],\n\t\t}\n\t] as any)\n\telectron.Menu.setApplicationMenu(appMenu)\n}\n\nfunction init() {\n\tif (awaken === undefined) {\n\t\treturn\n\t} else if (awaken) {\n\t\telectron.app.quit()\n\t\treturn\n\t}\n\n\tConfig.load().then(() => {\n\t\tService.connect().then(() => {\n\t\t\tif (process.argv.indexOf(\"--no-main\") !== -1) {\n\t\t\t\tif (Config.disable_tray_icon) {\n\t\t\t\t\telectron.app.quit()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet main = new Main()\n\t\t\t\tmain.run()\n\t\t\t}\n\n\t\t\tinitAppMenu()\n\n\t\t\tif (!Config.disable_tray_icon) {\n\t\t\t\tinitTray()\n\t\t\t}\n\n\t\t\tService.subscribe((event: Service.Event): void => {\n\t\t\t\tif (event.type === \"connected\") {\n\t\t\t\t\tif (tray) {\n\t\t\t\t\t\ttray.setImage(getTrayIcon(true))\n\t\t\t\t\t}\n\t\t\t\t} else if (event.type === \"disconnected\") {\n\t\t\t\t\tif (tray) {\n\t\t\t\t\t\ttray.setImage(getTrayIcon(false))\n\t\t\t\t\t}\n\t\t\t\t} else if (event.type === \"wakeup\") {\n\t\t\t\t\tService.send(\"awake\")\n\n\t\t\t\t\tlet main = new Main()\n\t\t\t\t\tmain.run()\n\t\t\t\t} else if (event.type === \"shutdown\") {\n\t\t\t\t\tif (process.argv.indexOf(\"--no-shutdown\") === -1) {\n\t\t\t\t\t\telectron.app.quit()\n\t\t\t\t\t}\n\t\t\t\t} else if (event.type === \"sso_auth\") {\n\t\t\t\t\tUtils.openLink(event.data.url)\n\t\t\t\t} else if (event.type === \"tpm_open\") {\n\t\t\t\t\tTpm.open(event.data.id, event.data.private_key)\n\t\t\t\t} else if (event.type === \"tpm_sign\") {\n\t\t\t\t\tTpm.sign(event.data.id, event.data.sign_data)\n\t\t\t\t} else if (event.type === \"tpm_close\") {\n\t\t\t\t\tTpm.close(event.data.id)\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t})\n}\n\nfunction getTrayIcon(state: boolean): string {\n\tlet connTray = \"\"\n\tlet disconnTray = \"\"\n\n\tif (process.platform === \"darwin\") {\n\t\tconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_connected_osxTemplate.png\")\n\t\tdisconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_disconnected_osxTemplate.png\")\n\t} else if (process.platform === \"win32\") {\n\t\tif (electron.nativeTheme.shouldUseDarkColors) {\n\t\t\tconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\t\"tray_connected_win_light.png\")\n\t\t\tdisconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\t\"tray_disconnected_win_light.png\")\n\t\t} else {\n\t\t\tconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\t\"tray_connected_win_dark.png\")\n\t\t\tdisconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\t\"tray_disconnected_win_dark.png\")\n\t\t}\n\t} else if (process.platform === \"linux\") {\n\t\tconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_connected_linux_light.png\")\n\t\tdisconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_disconnected_linux_light.png\")\n\t} else {\n\t\tconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_connected.png\")\n\t\tdisconnTray = path.join(__dirname, \"..\", \"img\",\n\t\t\t\"tray_disconnected.png\")\n\t}\n\n\tif (state) {\n\t\treturn connTray\n\t} else {\n\t\treturn disconnTray\n\t}\n}\n\nelectron.app.on(\"window-all-closed\", (): void => {\n\ttry {\n\t\tConfig.load().then(async (): Promise<void> => {\n\t\t\tif (windowSize && windowSize.length == 2) {\n\t\t\t\tConfig.window_width = windowSize[0]\n\t\t\t\tConfig.window_height = windowSize[1]\n\t\t\t\tawait Config.save({\n\t\t\t\t\twindow_width: Config.window_width,\n\t\t\t\t\twindow_height: Config.window_height,\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (Config.disable_tray_icon || !tray) {\n\t\t\t\telectron.app.quit()\n\t\t\t} else {\n\t\t\t\tif (electron.app.dock) {\n\t\t\t\t\telectron.app.dock.hide()\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n\nelectron.app.on(\"open-file\", (): void => {\n\ttry {\n\t\tlet main = new Main()\n\t\tmain.run()\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n\nelectron.app.on(\"open-url\", (): void => {\n\ttry {\n\t\tlet main = new Main()\n\t\tmain.run()\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n\nelectron.app.on(\"activate\", (): void => {\n\ttry {\n\t\tlet main = new Main()\n\t\tmain.run()\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n\nelectron.app.on(\"quit\", (): void => {\n\tService.cleanup()\n\ttry {\n\t\telectron.app.quit()\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n\nelectron.app.on(\"ready\", (): void => {\n\tlet profilesPth = path.join(electron.app.getPath(\"userData\"), \"profiles\")\n\t\tfs.exists(profilesPth, function(exists) {\n\t\tif (!exists) {\n\t\t\tfs.mkdir(profilesPth, function() {})\n\t\t}\n\t})\n\n\ttry {\n\t\tif (readyError) {\n\t\t\telectron.dialog.showMessageBox(null, {\n\t\t\t\ttype: \"error\",\n\t\t\t\tbuttons: [\"Exit\"],\n\t\t\t\ttitle: \"Pritunl Client - Process Error\",\n\t\t\t\tmessage: \"Error occured in main process:\\n\\n\" + readyError,\n\t\t\t}).then(function() {\n\t\t\t\telectron.app.quit()\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\tready = true\n\t\tinit()\n\t} catch (error) {\n\t\tthrow error\n\t}\n})\n"],"names":["EE","fs","EventEmitter","Stream","StringDecoder","proc","isStream","Minipass","isReadable","isWritable","EOF","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","DATALISTENERS","DISCARDED","defer","fn","nodefer","isEndish","ev","isArrayBufferLike","b","isArrayBufferView","Pipe","src","dest","opts","_er","PipeProxyErrors","er","isObjectModeOptions","o","isEncodingOptions","args","options","signal","_enc","_om","a","_","chunk","encoding","cb","n","ret","c","noDrain","ended","p","handler","h","data","buf","resolve","reject","stopped","stop","res","onerr","ondata","onend","ondestroy","value","rej","next","wc","writev","_autoClose","_close","_ended","_fd","_finished","_flags","_flush","_handleChunk","_makeBuf","_mode","_needDrain","_onerror","_onopen","_onread","_onwrite","_open","_path","_pos","_queue","_read","_readSize","_reading","_remain","_size","_write","_writing","_defaultFlag","_errored","ReadStream","path","opt","fd","br","ReadStreamSync","threw","WriteStream","defaultFlag","enc","bw","iovec","WriteStreamSync","dirname","parse","argmap","isSyncFile","isAsyncFile","isSyncNoFile","isAsyncNoFile","isFile","dealiasKey","k","d","dealias","result","key","v","makeCommand","syncFile","asyncFile","syncNoFile","asyncNoFile","validate","opt_","entries","assert","Buffer","realZlib","realZlibConstants","constants","OriginalBufferConcat","desc","noop","passthroughBufferConcat","makeNoOp","_superWrite","ZlibError","err","origin","_flushFlag","ZlibBase","#sawError","#ended","#flushFlag","#finishFlushFlag","#fullFlushFlag","#handle","#onError","mode","flushFlag","nativeHandle","originalNativeClose","originalClose","writeReturn","r","i","Zlib","#level","#strategy","level","strategy","origFlush","Gzip","#portable","Unzip","Brotli","BrotliCompress","BrotliDecompress","Zstd","ZstdCompress","ZstdDecompress","pathModule","encode","num","encodeNegative","encodePositive","flipped","byte","onesComp","twosComp","pre","pos","twos","len","sum","f","types_exports","__export","code","isCode","isName","name","kv","Header","#type","off","ex","gex","#slurp","decString","decNumber","decDate","t","prefix","prefixSize","split","splitPrefix","encString","encNumber","encDate","type","pp","root","size","numToDate","decSmallNumber","nanUndef","MAXNUM","encSmallNumber","octalString","padOctal","str","date","NULLS","basename","Pax","_Pax","obj","global","body","bodyLen","bufLen","field","s","byteLen","digits","g","merge","parseKV","parseKVLine","set","line","platform","normalizeWindowsPath","ReadEntry","header","writeLen","warnMethod","self","message","maxMetaEntrySize","gzipHeader","zstdHeader","ZIP_HEADER_LEN","STATE","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","DONE","SAW_VALID_ENTRY","SAW_NULL_BLOCK","SAW_EOF","CLOSESTREAM","Parser","isTBR","isTZST","position","entry","go","re","extra","error","isZstd","maybeBrotli","have","length","stripTrailingSlashes","slashesStart","onReadEntryFunction","onReadEntry","filesFilter","files","map","filter","mapHas","file","m","listFileSync","stat","readSize","read","bytesRead","listFile","_files","stream","list","modeFix","isDir","portable","win32","isAbsolute","stripAbsolutePath","parsed","raw","win","char","toWin","toRaw","decode","prefixPath","maxReadSize","PROCESS","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","AWAITDRAIN","ONDRAIN","PREFIX","WriteEntry","#hadError","pathWarn","stripped","cs","getType","block","linkpath","linkKey","offset","WriteEntrySync","WriteEntryTar","readEntry","Yallist","_Yallist","item","walker","node","prev","head","tail","l","push","unshift","thisp","initial","acc","arr","from","to","start","deleteCount","nodes","insertAfter","inserted","Node","PackJob","absolute","ONSTAT","CURRENT","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","Pack","zip","job","w","_job","sc","rc","msg","base","source","PackSync","createFileSync","addFilesSync","createFile","promise","addFilesAsync","createSync","createAsync","create","_opt","randomBytes","isWindows","O_CREAT","O_TRUNC","O_WRONLY","UV_FS_O_FILEMAP","fMapEnabled","fMapLimit","fMapFlag","getWriteFlag","lchownSync","uid","gid","chown","cpath","chownrKid","child","chownr","children","errState","then","chownrKidSync","chownrSync","e","fsp","CwdError","SymlinkError","symlink","checkCwd","dir","st","mkdir","umask","needChmod","doChown","preserve","unlink","cwd","done","created","made","parts","mkdir_","part","onmkdir","statEr","checkCwdSync","ok","mkdirSync","join","normalizeCache","MAX","cache","normalizeUnicode","getDirs","PathReservations","#queues","#reservations","#running","paths","dirs","q","#run","#getQueues","#clear","q0","ONENTRY","CHECKFS","CHECKFS2","ISREUSABLE","MAKEFS","LINK","ENSURE_NO_SYMLINK","UNSUPPORTED","CHECKPATH","STRIPABSOLUTEPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","CHECKED_CWD","DEFAULT_MAX_DEPTH","unlinkFile","unlinkFileSync","uint32","Unpack","entryDir","resolved","linkparts","aRoot","pRoot","fullyDone","actions","abs","atime","mtime","er2","tx","onError","parent","afterMakeParent","lstatEr","afterChmod","link","callSync","UnpackSync","mkParent","oner","closeError","futimeser","fchowner","_entry","linkSync","extractFileSync","u","extractFile","extract","replaceSync","headBuf","POSITION","bufPos","bytes","entryBlockSize","streamSync","replaceAsync","getPos","cb_","onread","flag","onopen","replace","update","mtimeFilter"],"sourceRoot":""}